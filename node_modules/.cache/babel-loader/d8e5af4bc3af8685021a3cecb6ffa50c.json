{"ast":null,"code":"import { isServer, isValidTimeout, noop, replaceData, shallowEqualObjects, timeUntilStale } from \"./utils.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { focusManager } from \"./focusManager.mjs\";\nimport { Subscribable } from \"./subscribable.mjs\";\nimport { canFetch, isCancelledError } from \"./retryer.mjs\";\nexport class QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    return this.createResult(query, options);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch() {\n    let {\n      refetchPage,\n      ...options\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    clearTimeout(this.staleTimeoutId);\n    this.staleTimeoutId = undefined;\n  }\n\n  clearRefetchInterval() {\n    clearInterval(this.refetchIntervalId);\n    this.refetchIntervalId = undefined;\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdateCount && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            placeholderData = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading: status === 'loading',\n      isSuccess: status === 'success',\n      isError: status === 'error',\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching: isFetching,\n      isRefetching: isFetching && status !== 'loading',\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n\n      if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}","map":{"version":3,"names":["isServer","isValidTimeout","noop","replaceData","shallowEqualObjects","timeUntilStale","notifyManager","focusManager","Subscribable","canFetch","isCancelledError","QueryObserver","constructor","client","options","trackedProps","Set","selectError","bindMethods","setOptions","remove","bind","refetch","onSubscribe","listeners","length","currentQuery","addObserver","shouldFetchOnMount","executeFetch","updateTimers","onUnsubscribe","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","removeObserver","notifyOptions","prevOptions","prevQuery","defaultQueryOptions","enabled","Error","queryKey","updateQuery","mounted","hasListeners","shouldFetchOptionally","updateResult","staleTime","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","query","getQueryCache","build","createResult","getCurrentResult","currentResult","trackResult","result","trackedResult","Object","keys","forEach","key","defineProperty","configurable","enumerable","get","add","getCurrentQuery","refetchPage","fetch","meta","fetchOptimistic","defaultedOptions","isFetchingOptimistic","then","fetchOptions","_fetchOptions$cancelR","cancelRefetch","promise","throwOnError","catch","isStale","time","dataUpdatedAt","timeout","staleTimeoutId","setTimeout","_this$options$refetch","refetchInterval","data","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","isFocused","clearTimeout","undefined","clearInterval","prevResult","prevResultState","currentResultState","prevResultOptions","currentResultOptions","queryChange","queryInitialState","state","currentQueryInitialState","prevQueryResult","previousQueryResult","error","errorUpdatedAt","fetchStatus","status","isPreviousData","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","networkMode","keepPreviousData","dataUpdateCount","isSuccess","select","selectFn","selectResult","process","env","NODE_ENV","getLogger","placeholderData","Date","now","isFetching","isLoading","isError","failureCount","fetchFailureCount","errorUpdateCount","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","nextResult","defaultNotifyOptions","cache","shouldNotifyListeners","notifyOnChangeProps","size","includedProps","useErrorBoundary","some","typedKey","changed","has","notify","onQueryUpdate","action","type","onSuccess","manual","onError","batch","_this$options$onSucce","_this$options","_this$options$onSettl","_this$options2","call","onSettled","_this$options$onError","_this$options3","_this$options$onSettl2","_this$options4","listener","shouldLoadOnMount","retryOnMount","refetchOnMount","field","value","suspense","isStaleByTime"],"sources":["/home/king-longs/Desktop/final/node_modules/react-query/lib/core/queryObserver.mjs"],"sourcesContent":["import { isServer, isValidTimeout, noop, replaceData, shallowEqualObjects, timeUntilStale } from \"./utils.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { focusManager } from \"./focusManager.mjs\";\nimport { Subscribable } from \"./subscribable.mjs\";\nimport { canFetch, isCancelledError } from \"./retryer.mjs\";\nexport class QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    return this.createResult(query, options);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    clearTimeout(this.staleTimeoutId);\n    this.staleTimeoutId = undefined;\n  }\n\n  clearRefetchInterval() {\n    clearInterval(this.refetchIntervalId);\n    this.refetchIntervalId = undefined;\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdateCount && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            placeholderData = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading: status === 'loading',\n      isSuccess: status === 'success',\n      isError: status === 'error',\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching: isFetching,\n      isRefetching: isFetching && status !== 'loading',\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n\n      if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}