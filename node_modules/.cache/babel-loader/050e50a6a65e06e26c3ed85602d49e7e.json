{"ast":null,"code":"import { getAbortController, noop, replaceData, timeUntilStale } from \"./utils.mjs\";\nimport { defaultLogger } from \"./logger.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { isCancelledError, canFetch, createRetryer } from \"./retryer.mjs\";\nimport { Removable } from \"./removable.mjs\"; // TYPES\n// CLASS\n\nexport class Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.meta = config.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.meta = options == null ? void 0 : options.meta;\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime() {\n    let staleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4; // make sure that retries that were potentially cancelled due to unmounts can continue\n\n\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config; // Notify cache callback\n\n\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on2, _this$cache$config2;\n\n        if (typeof data === 'undefined') {\n          onError(new Error('Query data cannot be undefined'));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: () => {\n        this.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: state.fetchFailureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasInitialData = typeof options.initialData !== 'undefined';\n  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  const hasData = typeof data !== 'undefined';\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}","map":{"version":3,"names":["getAbortController","noop","replaceData","timeUntilStale","defaultLogger","notifyManager","isCancelledError","canFetch","createRetryer","Removable","Query","constructor","config","abortSignalConsumed","defaultOptions","setOptions","options","observers","cache","logger","queryKey","queryHash","initialState","state","getDefaultState","meta","updateCacheTime","cacheTime","optionalRemove","length","fetchStatus","remove","setData","newData","data","dispatch","type","dataUpdatedAt","updatedAt","manual","setState","setStateOptions","cancel","_this$retryer","promise","retryer","then","catch","Promise","resolve","destroy","silent","reset","isActive","some","observer","enabled","isDisabled","getObserversCount","isStale","isInvalidated","getCurrentResult","isStaleByTime","staleTime","onFocus","_this$retryer2","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","onOnline","_this$retryer3","shouldFetchOnReconnect","addObserver","indexOf","push","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","scheduleGc","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","continueRetry","queryFn","Array","isArray","process","env","NODE_ENV","error","abortController","queryFnContext","pageParam","undefined","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","fetchFn","reject","context","behavior","onFetch","revertState","fetchMeta","_context$fetchOptions2","onError","_this$cache$config$on","_this$cache$config","call","isFetchingOptimistic","fn","abort","bind","onSuccess","_this$cache$config$on2","_this$cache$config2","Error","onFail","onPause","onContinue","retry","retryDelay","networkMode","action","reducer","_action$meta","_action$dataUpdatedAt","fetchFailureCount","status","dataUpdateCount","Date","now","errorUpdateCount","errorUpdatedAt","batch","forEach","onQueryUpdate","initialData","hasInitialData","initialDataUpdatedAt","hasData"],"sources":["/home/king-longs/Desktop/final/node_modules/react-query/lib/core/query.mjs"],"sourcesContent":["import { getAbortController, noop, replaceData, timeUntilStale } from \"./utils.mjs\";\nimport { defaultLogger } from \"./logger.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { isCancelledError, canFetch, createRetryer } from \"./retryer.mjs\";\nimport { Removable } from \"./removable.mjs\"; // TYPES\n\n// CLASS\nexport class Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.meta = config.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.meta = options == null ? void 0 : options.meta;\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on2, _this$cache$config2;\n\n        if (typeof data === 'undefined') {\n          onError(new Error('Query data cannot be undefined'));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: () => {\n        this.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: state.fetchFailureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasInitialData = typeof options.initialData !== 'undefined';\n  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  const hasData = typeof data !== 'undefined';\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}"],"mappings":"AAAA,SAASA,kBAAT,EAA6BC,IAA7B,EAAmCC,WAAnC,EAAgDC,cAAhD,QAAsE,aAAtE;AACA,SAASC,aAAT,QAA8B,cAA9B;AACA,SAASC,aAAT,QAA8B,qBAA9B;AACA,SAASC,gBAAT,EAA2BC,QAA3B,EAAqCC,aAArC,QAA0D,eAA1D;AACA,SAASC,SAAT,QAA0B,iBAA1B,C,CAA6C;AAE7C;;AACA,OAAO,MAAMC,KAAN,SAAoBD,SAApB,CAA8B;EACnCE,WAAW,CAACC,MAAD,EAAS;IAClB;IACA,KAAKC,mBAAL,GAA2B,KAA3B;IACA,KAAKC,cAAL,GAAsBF,MAAM,CAACE,cAA7B;IACA,KAAKC,UAAL,CAAgBH,MAAM,CAACI,OAAvB;IACA,KAAKC,SAAL,GAAiB,EAAjB;IACA,KAAKC,KAAL,GAAaN,MAAM,CAACM,KAApB;IACA,KAAKC,MAAL,GAAcP,MAAM,CAACO,MAAP,IAAiBf,aAA/B;IACA,KAAKgB,QAAL,GAAgBR,MAAM,CAACQ,QAAvB;IACA,KAAKC,SAAL,GAAiBT,MAAM,CAACS,SAAxB;IACA,KAAKC,YAAL,GAAoBV,MAAM,CAACW,KAAP,IAAgBC,eAAe,CAAC,KAAKR,OAAN,CAAnD;IACA,KAAKO,KAAL,GAAa,KAAKD,YAAlB;IACA,KAAKG,IAAL,GAAYb,MAAM,CAACa,IAAnB;EACD;;EAEDV,UAAU,CAACC,OAAD,EAAU;IAClB,KAAKA,OAAL,GAAe,EAAE,GAAG,KAAKF,cAAV;MACb,GAAGE;IADU,CAAf;IAGA,KAAKS,IAAL,GAAYT,OAAO,IAAI,IAAX,GAAkB,KAAK,CAAvB,GAA2BA,OAAO,CAACS,IAA/C;IACA,KAAKC,eAAL,CAAqB,KAAKV,OAAL,CAAaW,SAAlC;EACD;;EAEDC,cAAc,GAAG;IACf,IAAI,CAAC,KAAKX,SAAL,CAAeY,MAAhB,IAA0B,KAAKN,KAAL,CAAWO,WAAX,KAA2B,MAAzD,EAAiE;MAC/D,KAAKZ,KAAL,CAAWa,MAAX,CAAkB,IAAlB;IACD;EACF;;EAEDC,OAAO,CAACC,OAAD,EAAUjB,OAAV,EAAmB;IACxB,MAAMkB,IAAI,GAAGhC,WAAW,CAAC,KAAKqB,KAAL,CAAWW,IAAZ,EAAkBD,OAAlB,EAA2B,KAAKjB,OAAhC,CAAxB,CADwB,CAC0C;;IAElE,KAAKmB,QAAL,CAAc;MACZD,IADY;MAEZE,IAAI,EAAE,SAFM;MAGZC,aAAa,EAAErB,OAAO,IAAI,IAAX,GAAkB,KAAK,CAAvB,GAA2BA,OAAO,CAACsB,SAHtC;MAIZC,MAAM,EAAEvB,OAAO,IAAI,IAAX,GAAkB,KAAK,CAAvB,GAA2BA,OAAO,CAACuB;IAJ/B,CAAd;IAMA,OAAOL,IAAP;EACD;;EAEDM,QAAQ,CAACjB,KAAD,EAAQkB,eAAR,EAAyB;IAC/B,KAAKN,QAAL,CAAc;MACZC,IAAI,EAAE,UADM;MAEZb,KAFY;MAGZkB;IAHY,CAAd;EAKD;;EAEDC,MAAM,CAAC1B,OAAD,EAAU;IACd,IAAI2B,aAAJ;;IAEA,MAAMC,OAAO,GAAG,KAAKA,OAArB;IACA,CAACD,aAAa,GAAG,KAAKE,OAAtB,KAAkC,IAAlC,GAAyC,KAAK,CAA9C,GAAkDF,aAAa,CAACD,MAAd,CAAqB1B,OAArB,CAAlD;IACA,OAAO4B,OAAO,GAAGA,OAAO,CAACE,IAAR,CAAa7C,IAAb,EAAmB8C,KAAnB,CAAyB9C,IAAzB,CAAH,GAAoC+C,OAAO,CAACC,OAAR,EAAlD;EACD;;EAEDC,OAAO,GAAG;IACR,MAAMA,OAAN;IACA,KAAKR,MAAL,CAAY;MACVS,MAAM,EAAE;IADE,CAAZ;EAGD;;EAEDC,KAAK,GAAG;IACN,KAAKF,OAAL;IACA,KAAKV,QAAL,CAAc,KAAKlB,YAAnB;EACD;;EAED+B,QAAQ,GAAG;IACT,OAAO,KAAKpC,SAAL,CAAeqC,IAAf,CAAoBC,QAAQ,IAAIA,QAAQ,CAACvC,OAAT,CAAiBwC,OAAjB,KAA6B,KAA7D,CAAP;EACD;;EAEDC,UAAU,GAAG;IACX,OAAO,KAAKC,iBAAL,KAA2B,CAA3B,IAAgC,CAAC,KAAKL,QAAL,EAAxC;EACD;;EAEDM,OAAO,GAAG;IACR,OAAO,KAAKpC,KAAL,CAAWqC,aAAX,IAA4B,CAAC,KAAKrC,KAAL,CAAWc,aAAxC,IAAyD,KAAKpB,SAAL,CAAeqC,IAAf,CAAoBC,QAAQ,IAAIA,QAAQ,CAACM,gBAAT,GAA4BF,OAA5D,CAAhE;EACD;;EAEDG,aAAa,GAAgB;IAAA,IAAfC,SAAe,uEAAH,CAAG;IAC3B,OAAO,KAAKxC,KAAL,CAAWqC,aAAX,IAA4B,CAAC,KAAKrC,KAAL,CAAWc,aAAxC,IAAyD,CAAClC,cAAc,CAAC,KAAKoB,KAAL,CAAWc,aAAZ,EAA2B0B,SAA3B,CAA/E;EACD;;EAEDC,OAAO,GAAG;IACR,IAAIC,cAAJ;;IAEA,MAAMV,QAAQ,GAAG,KAAKtC,SAAL,CAAeiD,IAAf,CAAoBC,CAAC,IAAIA,CAAC,CAACC,wBAAF,EAAzB,CAAjB;;IAEA,IAAIb,QAAJ,EAAc;MACZA,QAAQ,CAACc,OAAT,CAAiB;QACfC,aAAa,EAAE;MADA,CAAjB;IAGD,CATO,CASN;;;IAGF,CAACL,cAAc,GAAG,KAAKpB,OAAvB,KAAmC,IAAnC,GAA0C,KAAK,CAA/C,GAAmDoB,cAAc,CAACM,QAAf,EAAnD;EACD;;EAEDC,QAAQ,GAAG;IACT,IAAIC,cAAJ;;IAEA,MAAMlB,QAAQ,GAAG,KAAKtC,SAAL,CAAeiD,IAAf,CAAoBC,CAAC,IAAIA,CAAC,CAACO,sBAAF,EAAzB,CAAjB;;IAEA,IAAInB,QAAJ,EAAc;MACZA,QAAQ,CAACc,OAAT,CAAiB;QACfC,aAAa,EAAE;MADA,CAAjB;IAGD,CATQ,CASP;;;IAGF,CAACG,cAAc,GAAG,KAAK5B,OAAvB,KAAmC,IAAnC,GAA0C,KAAK,CAA/C,GAAmD4B,cAAc,CAACF,QAAf,EAAnD;EACD;;EAEDI,WAAW,CAACpB,QAAD,EAAW;IACpB,IAAI,KAAKtC,SAAL,CAAe2D,OAAf,CAAuBrB,QAAvB,MAAqC,CAAC,CAA1C,EAA6C;MAC3C,KAAKtC,SAAL,CAAe4D,IAAf,CAAoBtB,QAApB,EAD2C,CACZ;;MAE/B,KAAKuB,cAAL;MACA,KAAK5D,KAAL,CAAW6D,MAAX,CAAkB;QAChB3C,IAAI,EAAE,eADU;QAEhB4C,KAAK,EAAE,IAFS;QAGhBzB;MAHgB,CAAlB;IAKD;EACF;;EAED0B,cAAc,CAAC1B,QAAD,EAAW;IACvB,IAAI,KAAKtC,SAAL,CAAe2D,OAAf,CAAuBrB,QAAvB,MAAqC,CAAC,CAA1C,EAA6C;MAC3C,KAAKtC,SAAL,GAAiB,KAAKA,SAAL,CAAeiE,MAAf,CAAsBf,CAAC,IAAIA,CAAC,KAAKZ,QAAjC,CAAjB;;MAEA,IAAI,CAAC,KAAKtC,SAAL,CAAeY,MAApB,EAA4B;QAC1B;QACA;QACA,IAAI,KAAKgB,OAAT,EAAkB;UAChB,IAAI,KAAKhC,mBAAT,EAA8B;YAC5B,KAAKgC,OAAL,CAAaH,MAAb,CAAoB;cAClByC,MAAM,EAAE;YADU,CAApB;UAGD,CAJD,MAIO;YACL,KAAKtC,OAAL,CAAauC,WAAb;UACD;QACF;;QAED,KAAKC,UAAL;MACD;;MAED,KAAKnE,KAAL,CAAW6D,MAAX,CAAkB;QAChB3C,IAAI,EAAE,iBADU;QAEhB4C,KAAK,EAAE,IAFS;QAGhBzB;MAHgB,CAAlB;IAKD;EACF;;EAEDG,iBAAiB,GAAG;IAClB,OAAO,KAAKzC,SAAL,CAAeY,MAAtB;EACD;;EAEDyD,UAAU,GAAG;IACX,IAAI,CAAC,KAAK/D,KAAL,CAAWqC,aAAhB,EAA+B;MAC7B,KAAKzB,QAAL,CAAc;QACZC,IAAI,EAAE;MADM,CAAd;IAGD;EACF;;EAEDmD,KAAK,CAACvE,OAAD,EAAUwE,YAAV,EAAwB;IAC3B,IAAIC,qBAAJ,EAA2BC,qBAA3B;;IAEA,IAAI,KAAKnE,KAAL,CAAWO,WAAX,KAA2B,MAA/B,EAAuC;MACrC,IAAI,KAAKP,KAAL,CAAWc,aAAX,IAA4BmD,YAAY,IAAI,IAA5C,IAAoDA,YAAY,CAAClB,aAArE,EAAoF;QAClF;QACA,KAAK5B,MAAL,CAAY;UACVS,MAAM,EAAE;QADE,CAAZ;MAGD,CALD,MAKO,IAAI,KAAKP,OAAT,EAAkB;QACvB,IAAI+C,cAAJ,CADuB,CAGvB;;;QACA,CAACA,cAAc,GAAG,KAAK9C,OAAvB,KAAmC,IAAnC,GAA0C,KAAK,CAA/C,GAAmD8C,cAAc,CAACC,aAAf,EAAnD,CAJuB,CAI4D;;QAEnF,OAAO,KAAKhD,OAAZ;MACD;IACF,CAjB0B,CAiBzB;;;IAGF,IAAI5B,OAAJ,EAAa;MACX,KAAKD,UAAL,CAAgBC,OAAhB;IACD,CAtB0B,CAsBzB;IACF;;;IAGA,IAAI,CAAC,KAAKA,OAAL,CAAa6E,OAAlB,EAA2B;MACzB,MAAMtC,QAAQ,GAAG,KAAKtC,SAAL,CAAeiD,IAAf,CAAoBC,CAAC,IAAIA,CAAC,CAACnD,OAAF,CAAU6E,OAAnC,CAAjB;;MAEA,IAAItC,QAAJ,EAAc;QACZ,KAAKxC,UAAL,CAAgBwC,QAAQ,CAACvC,OAAzB;MACD;IACF;;IAED,IAAI,CAAC8E,KAAK,CAACC,OAAN,CAAc,KAAK/E,OAAL,CAAaI,QAA3B,CAAL,EAA2C;MACzC,IAAI4E,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;QACzC,KAAK/E,MAAL,CAAYgF,KAAZ,CAAkB,qIAAlB;MACD;IACF;;IAED,MAAMC,eAAe,GAAGpG,kBAAkB,EAA1C,CAxC2B,CAwCmB;;IAE9C,MAAMqG,cAAc,GAAG;MACrBjF,QAAQ,EAAE,KAAKA,QADM;MAErBkF,SAAS,EAAEC,SAFU;MAGrB9E,IAAI,EAAE,KAAKA;IAHU,CAAvB,CA1C2B,CA8CxB;IACH;IACA;;IAEA,MAAM+E,iBAAiB,GAAGC,MAAM,IAAI;MAClCC,MAAM,CAACC,cAAP,CAAsBF,MAAtB,EAA8B,QAA9B,EAAwC;QACtCG,UAAU,EAAE,IAD0B;QAEtCC,GAAG,EAAE,MAAM;UACT,IAAIT,eAAJ,EAAqB;YACnB,KAAKvF,mBAAL,GAA2B,IAA3B;YACA,OAAOuF,eAAe,CAACU,MAAvB;UACD;;UAED,OAAOP,SAAP;QACD;MATqC,CAAxC;IAWD,CAZD;;IAcAC,iBAAiB,CAACH,cAAD,CAAjB,CAhE2B,CAgEQ;;IAEnC,MAAMU,OAAO,GAAG,MAAM;MACpB,IAAI,CAAC,KAAK/F,OAAL,CAAa6E,OAAlB,EAA2B;QACzB,OAAO7C,OAAO,CAACgE,MAAR,CAAe,iBAAf,CAAP;MACD;;MAED,KAAKnG,mBAAL,GAA2B,KAA3B;MACA,OAAO,KAAKG,OAAL,CAAa6E,OAAb,CAAqBQ,cAArB,CAAP;IACD,CAPD,CAlE2B,CAyExB;;;IAGH,MAAMY,OAAO,GAAG;MACdzB,YADc;MAEdxE,OAAO,EAAE,KAAKA,OAFA;MAGdI,QAAQ,EAAE,KAAKA,QAHD;MAIdG,KAAK,EAAE,KAAKA,KAJE;MAKdwF,OALc;MAMdtF,IAAI,EAAE,KAAKA;IANG,CAAhB;IAQA+E,iBAAiB,CAACS,OAAD,CAAjB;IACA,CAACxB,qBAAqB,GAAG,KAAKzE,OAAL,CAAakG,QAAtC,KAAmD,IAAnD,GAA0D,KAAK,CAA/D,GAAmEzB,qBAAqB,CAAC0B,OAAtB,CAA8BF,OAA9B,CAAnE,CArF2B,CAqFgF;;IAE3G,KAAKG,WAAL,GAAmB,KAAK7F,KAAxB,CAvF2B,CAuFI;;IAE/B,IAAI,KAAKA,KAAL,CAAWO,WAAX,KAA2B,MAA3B,IAAqC,KAAKP,KAAL,CAAW8F,SAAX,MAA0B,CAAC3B,qBAAqB,GAAGuB,OAAO,CAACzB,YAAjC,KAAkD,IAAlD,GAAyD,KAAK,CAA9D,GAAkEE,qBAAqB,CAACjE,IAAlH,CAAzC,EAAkK;MAChK,IAAI6F,sBAAJ;;MAEA,KAAKnF,QAAL,CAAc;QACZC,IAAI,EAAE,OADM;QAEZX,IAAI,EAAE,CAAC6F,sBAAsB,GAAGL,OAAO,CAACzB,YAAlC,KAAmD,IAAnD,GAA0D,KAAK,CAA/D,GAAmE8B,sBAAsB,CAAC7F;MAFpF,CAAd;IAID;;IAED,MAAM8F,OAAO,GAAGpB,KAAK,IAAI;MACvB;MACA,IAAI,EAAE7F,gBAAgB,CAAC6F,KAAD,CAAhB,IAA2BA,KAAK,CAAChD,MAAnC,CAAJ,EAAgD;QAC9C,KAAKhB,QAAL,CAAc;UACZC,IAAI,EAAE,OADM;UAEZ+D,KAAK,EAAEA;QAFK,CAAd;MAID;;MAED,IAAI,CAAC7F,gBAAgB,CAAC6F,KAAD,CAArB,EAA8B;QAC5B,IAAIqB,qBAAJ,EAA2BC,kBAA3B,CAD4B,CAG5B;;;QACA,CAACD,qBAAqB,GAAG,CAACC,kBAAkB,GAAG,KAAKvG,KAAL,CAAWN,MAAjC,EAAyC2G,OAAlE,KAA8E,IAA9E,GAAqF,KAAK,CAA1F,GAA8FC,qBAAqB,CAACE,IAAtB,CAA2BD,kBAA3B,EAA+CtB,KAA/C,EAAsD,IAAtD,CAA9F;;QAEA,IAAIH,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;UACzC,KAAK/E,MAAL,CAAYgF,KAAZ,CAAkBA,KAAlB;QACD;MACF;;MAED,IAAI,CAAC,KAAKwB,oBAAV,EAAgC;QAC9B;QACA,KAAKtC,UAAL;MACD;;MAED,KAAKsC,oBAAL,GAA4B,KAA5B;IACD,CA1BD,CAlG2B,CA4HxB;;;IAGH,KAAK9E,OAAL,GAAerC,aAAa,CAAC;MAC3BoH,EAAE,EAAEX,OAAO,CAACF,OADe;MAE3Bc,KAAK,EAAEzB,eAAe,IAAI,IAAnB,GAA0B,KAAK,CAA/B,GAAmCA,eAAe,CAACyB,KAAhB,CAAsBC,IAAtB,CAA2B1B,eAA3B,CAFf;MAG3B2B,SAAS,EAAE7F,IAAI,IAAI;QACjB,IAAI8F,sBAAJ,EAA4BC,mBAA5B;;QAEA,IAAI,OAAO/F,IAAP,KAAgB,WAApB,EAAiC;UAC/BqF,OAAO,CAAC,IAAIW,KAAJ,CAAU,gCAAV,CAAD,CAAP;UACA;QACD;;QAED,KAAKlG,OAAL,CAAaE,IAAb,EARiB,CAQG;;QAEpB,CAAC8F,sBAAsB,GAAG,CAACC,mBAAmB,GAAG,KAAK/G,KAAL,CAAWN,MAAlC,EAA0CmH,SAApE,KAAkF,IAAlF,GAAyF,KAAK,CAA9F,GAAkGC,sBAAsB,CAACN,IAAvB,CAA4BO,mBAA5B,EAAiD/F,IAAjD,EAAuD,IAAvD,CAAlG;;QAEA,IAAI,CAAC,KAAKyF,oBAAV,EAAgC;UAC9B;UACA,KAAKtC,UAAL;QACD;;QAED,KAAKsC,oBAAL,GAA4B,KAA5B;MACD,CArB0B;MAsB3BJ,OAtB2B;MAuB3BY,MAAM,EAAE,MAAM;QACZ,KAAKhG,QAAL,CAAc;UACZC,IAAI,EAAE;QADM,CAAd;MAGD,CA3B0B;MA4B3BgG,OAAO,EAAE,MAAM;QACb,KAAKjG,QAAL,CAAc;UACZC,IAAI,EAAE;QADM,CAAd;MAGD,CAhC0B;MAiC3BiG,UAAU,EAAE,MAAM;QAChB,KAAKlG,QAAL,CAAc;UACZC,IAAI,EAAE;QADM,CAAd;MAGD,CArC0B;MAsC3BkG,KAAK,EAAErB,OAAO,CAACjG,OAAR,CAAgBsH,KAtCI;MAuC3BC,UAAU,EAAEtB,OAAO,CAACjG,OAAR,CAAgBuH,UAvCD;MAwC3BC,WAAW,EAAEvB,OAAO,CAACjG,OAAR,CAAgBwH;IAxCF,CAAD,CAA5B;IA0CA,KAAK5F,OAAL,GAAe,KAAKC,OAAL,CAAaD,OAA5B;IACA,OAAO,KAAKA,OAAZ;EACD;;EAEDT,QAAQ,CAACsG,MAAD,EAAS;IACf,MAAMC,OAAO,GAAGnH,KAAK,IAAI;MACvB,IAAIoH,YAAJ,EAAkBC,qBAAlB;;MAEA,QAAQH,MAAM,CAACrG,IAAf;QACE,KAAK,QAAL;UACE,OAAO,EAAE,GAAGb,KAAL;YACLsH,iBAAiB,EAAEtH,KAAK,CAACsH,iBAAN,GAA0B;UADxC,CAAP;;QAIF,KAAK,OAAL;UACE,OAAO,EAAE,GAAGtH,KAAL;YACLO,WAAW,EAAE;UADR,CAAP;;QAIF,KAAK,UAAL;UACE,OAAO,EAAE,GAAGP,KAAL;YACLO,WAAW,EAAE;UADR,CAAP;;QAIF,KAAK,OAAL;UACE,OAAO,EAAE,GAAGP,KAAL;YACLsH,iBAAiB,EAAE,CADd;YAELxB,SAAS,EAAE,CAACsB,YAAY,GAAGF,MAAM,CAAChH,IAAvB,KAAgC,IAAhC,GAAuCkH,YAAvC,GAAsD,IAF5D;YAGL7G,WAAW,EAAEvB,QAAQ,CAAC,KAAKS,OAAL,CAAawH,WAAd,CAAR,GAAqC,UAArC,GAAkD,QAH1D;YAIL,IAAI,CAACjH,KAAK,CAACc,aAAP,IAAwB;cAC1B8D,KAAK,EAAE,IADmB;cAE1B2C,MAAM,EAAE;YAFkB,CAA5B;UAJK,CAAP;;QAUF,KAAK,SAAL;UACE,OAAO,EAAE,GAAGvH,KAAL;YACLW,IAAI,EAAEuG,MAAM,CAACvG,IADR;YAEL6G,eAAe,EAAExH,KAAK,CAACwH,eAAN,GAAwB,CAFpC;YAGL1G,aAAa,EAAE,CAACuG,qBAAqB,GAAGH,MAAM,CAACpG,aAAhC,KAAkD,IAAlD,GAAyDuG,qBAAzD,GAAiFI,IAAI,CAACC,GAAL,EAH3F;YAIL9C,KAAK,EAAE,IAJF;YAKLvC,aAAa,EAAE,KALV;YAMLkF,MAAM,EAAE,SANH;YAOL,IAAI,CAACL,MAAM,CAAClG,MAAR,IAAkB;cACpBT,WAAW,EAAE,MADO;cAEpB+G,iBAAiB,EAAE;YAFC,CAAtB;UAPK,CAAP;;QAaF,KAAK,OAAL;UACE,MAAM1C,KAAK,GAAGsC,MAAM,CAACtC,KAArB;;UAEA,IAAI7F,gBAAgB,CAAC6F,KAAD,CAAhB,IAA2BA,KAAK,CAAChB,MAAjC,IAA2C,KAAKiC,WAApD,EAAiE;YAC/D,OAAO,EAAE,GAAG,KAAKA;YAAV,CAAP;UAED;;UAED,OAAO,EAAE,GAAG7F,KAAL;YACL4E,KAAK,EAAEA,KADF;YAEL+C,gBAAgB,EAAE3H,KAAK,CAAC2H,gBAAN,GAAyB,CAFtC;YAGLC,cAAc,EAAEH,IAAI,CAACC,GAAL,EAHX;YAILJ,iBAAiB,EAAEtH,KAAK,CAACsH,iBAAN,GAA0B,CAJxC;YAKL/G,WAAW,EAAE,MALR;YAMLgH,MAAM,EAAE;UANH,CAAP;;QASF,KAAK,YAAL;UACE,OAAO,EAAE,GAAGvH,KAAL;YACLqC,aAAa,EAAE;UADV,CAAP;;QAIF,KAAK,UAAL;UACE,OAAO,EAAE,GAAGrC,KAAL;YACL,GAAGkH,MAAM,CAAClH;UADL,CAAP;MAhEJ;IAoED,CAvED;;IAyEA,KAAKA,KAAL,GAAamH,OAAO,CAAC,KAAKnH,KAAN,CAApB;IACAlB,aAAa,CAAC+I,KAAd,CAAoB,MAAM;MACxB,KAAKnI,SAAL,CAAeoI,OAAf,CAAuB9F,QAAQ,IAAI;QACjCA,QAAQ,CAAC+F,aAAT,CAAuBb,MAAvB;MACD,CAFD;MAGA,KAAKvH,KAAL,CAAW6D,MAAX,CAAkB;QAChBC,KAAK,EAAE,IADS;QAEhB5C,IAAI,EAAE,SAFU;QAGhBqG;MAHgB,CAAlB;IAKD,CATD;EAUD;;AA3akC;;AA+arC,SAASjH,eAAT,CAAyBR,OAAzB,EAAkC;EAChC,MAAMkB,IAAI,GAAG,OAAOlB,OAAO,CAACuI,WAAf,KAA+B,UAA/B,GAA4CvI,OAAO,CAACuI,WAAR,EAA5C,GAAoEvI,OAAO,CAACuI,WAAzF;EACA,MAAMC,cAAc,GAAG,OAAOxI,OAAO,CAACuI,WAAf,KAA+B,WAAtD;EACA,MAAME,oBAAoB,GAAGD,cAAc,GAAG,OAAOxI,OAAO,CAACyI,oBAAf,KAAwC,UAAxC,GAAqDzI,OAAO,CAACyI,oBAAR,EAArD,GAAsFzI,OAAO,CAACyI,oBAAjG,GAAwH,CAAnK;EACA,MAAMC,OAAO,GAAG,OAAOxH,IAAP,KAAgB,WAAhC;EACA,OAAO;IACLA,IADK;IAEL6G,eAAe,EAAE,CAFZ;IAGL1G,aAAa,EAAEqH,OAAO,GAAGD,oBAAoB,IAAI,IAAxB,GAA+BA,oBAA/B,GAAsDT,IAAI,CAACC,GAAL,EAAzD,GAAsE,CAHvF;IAIL9C,KAAK,EAAE,IAJF;IAKL+C,gBAAgB,EAAE,CALb;IAMLC,cAAc,EAAE,CANX;IAOLN,iBAAiB,EAAE,CAPd;IAQLxB,SAAS,EAAE,IARN;IASLzD,aAAa,EAAE,KATV;IAULkF,MAAM,EAAEY,OAAO,GAAG,SAAH,GAAe,SAVzB;IAWL5H,WAAW,EAAE;EAXR,CAAP;AAaD"},"metadata":{},"sourceType":"module"}