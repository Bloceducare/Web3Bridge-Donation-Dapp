{"ast":null,"code":"import * as React from 'react';\nimport { createClient as createClient$1, getProvider, watchProvider, getWebSocketProvider, watchWebSocketProvider, watchAccount, getAccount, fetchBlockNumber, fetchFeeData, fetchBalance, Connector, connect, disconnect, getNetwork, watchNetwork, switchNetwork, watchSigner, fetchSigner, signMessage, signTypedData, getContract, watchReadContract, readContract, writeContract, fetchToken, fetchEnsAddress, fetchEnsAvatar, fetchEnsName, fetchEnsResolver, sendTransaction, waitForTransaction } from '@wagmi/core';\nexport { AddChainError, ChainNotConfiguredError, Client, Connector, ConnectorAlreadyConnectedError, ConnectorNotFoundError, ProviderRpcError, ResourceUnavailableError, RpcError, SwitchChainError, SwitchChainNotSupportedError, UserRejectedRequestError, alchemyRpcUrls, allChains, chain, chainId, configureChains, createStorage, defaultChains, defaultL2Chains, erc20ABI, erc721ABI, etherscanBlockExplorers, infuraRpcUrls } from '@wagmi/core';\nimport { QueryClient, QueryClientProvider, useQueryClient, useIsRestoring, useQueryErrorResetBoundary, notifyManager, QueryObserver, useMutation } from 'react-query';\nimport { persistQueryClient } from 'react-query/persistQueryClient';\nimport { createWebStoragePersister } from 'react-query/createWebStoragePersister';\nimport { BigNumber, Contract } from 'ethers/lib/ethers';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\n\nconst findAndReplace = (cacheRef, _ref) => {\n  let {\n    find,\n    replace\n  } = _ref;\n\n  if (cacheRef && find(cacheRef)) {\n    return replace(cacheRef);\n  }\n\n  if (typeof cacheRef !== 'object') {\n    return cacheRef;\n  }\n\n  if (Array.isArray(cacheRef)) {\n    return cacheRef.map(item => findAndReplace(item, {\n      find,\n      replace\n    }));\n  }\n\n  if (cacheRef instanceof Object) {\n    return Object.entries(cacheRef).reduce((curr, _ref2) => {\n      let [key, value] = _ref2;\n      return { ...curr,\n        [key]: findAndReplace(value, {\n          find,\n          replace\n        })\n      };\n    }, {});\n  }\n\n  return cacheRef;\n};\n\nfunction deserialize(cachedString) {\n  const cache = JSON.parse(cachedString);\n  const deserializedCacheWithBigNumbers = findAndReplace(cache, {\n    find: data => data.type === 'BigNumber',\n    replace: data => BigNumber.from(data.hex)\n  });\n  return deserializedCacheWithBigNumbers;\n}\n\nfunction isPlainArray(value) {\n  return Array.isArray(value) && Object.keys(value).length === value.length;\n}\n\nfunction parseContractResult(_ref) {\n  let {\n    contractInterface,\n    data,\n    functionName\n  } = _ref;\n\n  if (data && isPlainArray(data)) {\n    var _fragment$outputs, _fragment$outputs$, _fragment$outputs2, _fragment$outputs2$;\n\n    const iface = Contract.getInterface(contractInterface);\n    const fragment = iface.getFunction(functionName);\n    const isArray = (fragment === null || fragment === void 0 ? void 0 : (_fragment$outputs = fragment.outputs) === null || _fragment$outputs === void 0 ? void 0 : (_fragment$outputs$ = _fragment$outputs[0]) === null || _fragment$outputs$ === void 0 ? void 0 : _fragment$outputs$.baseType) === 'array' || (fragment === null || fragment === void 0 ? void 0 : (_fragment$outputs2 = fragment.outputs) === null || _fragment$outputs2 === void 0 ? void 0 : (_fragment$outputs2$ = _fragment$outputs2[0]) === null || _fragment$outputs2$ === void 0 ? void 0 : _fragment$outputs2$.baseType) === 'tuple';\n    const data_ = isArray ? [data] : data;\n    const encodedResult = iface.encodeFunctionResult(functionName, data_);\n    const decodedResult = iface.decodeFunctionResult(functionName, encodedResult);\n    return isArray ? decodedResult[0] : decodedResult;\n  }\n\n  return data;\n}\n/**\n * @function getReferenceKey\n *\n * @description\n * get the reference key for the circular value\n *\n * @param keys the keys to build the reference key from\n * @param cutoff the maximum number of keys to include\n * @returns the reference key\n */\n\n\nfunction getReferenceKey(keys, cutoff) {\n  return keys.slice(0, cutoff).join('.') || '.';\n}\n/**\n * @function getCutoff\n *\n * @description\n * faster `Array.prototype.indexOf` implementation build for slicing / splicing\n *\n * @param array the array to match the value in\n * @param value the value to match\n * @returns the matching index, or -1\n */\n\n\nfunction getCutoff(array, value) {\n  const {\n    length\n  } = array;\n\n  for (let index = 0; index < length; ++index) {\n    if (array[index] === value) {\n      return index + 1;\n    }\n  }\n\n  return 0;\n}\n/**\n * @function createReplacer\n *\n * @description\n * create a replacer method that handles circular values\n *\n * @param [replacer] a custom replacer to use for non-circular values\n * @param [circularReplacer] a custom replacer to use for circular methods\n * @returns the value to stringify\n */\n\n\nfunction createReplacer(replacer, circularReplacer) {\n  const hasReplacer = typeof replacer === 'function';\n  const hasCircularReplacer = typeof circularReplacer === 'function';\n  const cache = [];\n  const keys = [];\n  return function replace(key, value) {\n    if (typeof value === 'object') {\n      if (cache.length) {\n        const thisCutoff = getCutoff(cache, this);\n\n        if (thisCutoff === 0) {\n          cache[cache.length] = this;\n        } else {\n          cache.splice(thisCutoff);\n          keys.splice(thisCutoff);\n        }\n\n        keys[keys.length] = key;\n        const valueCutoff = getCutoff(cache, value);\n\n        if (valueCutoff !== 0) {\n          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : \"[ref=\".concat(getReferenceKey(keys, valueCutoff), \"]\");\n        }\n      } else {\n        cache[0] = value;\n        keys[0] = key;\n      }\n    }\n\n    return hasReplacer ? replacer.call(this, key, value) : value;\n  };\n}\n/**\n * @function stringify\n *\n * @description\n * strinigifer that handles circular values\n * Forked from https://github.com/planttheidea/fast-stringify\n *\n * @param value to stringify\n * @param [replacer] a custom replacer function for handling standard values\n * @param [indent] the number of spaces to indent the output by\n * @param [circularReplacer] a custom replacer function for handling circular values\n * @returns the stringified output\n */\n\n\nfunction serialize(value, replacer, indent, circularReplacer) {\n  return JSON.stringify(value, createReplacer(replacer, circularReplacer), indent !== null && indent !== void 0 ? indent : undefined);\n}\n\nfunction createClient() {\n  let {\n    queryClient = new QueryClient({\n      defaultOptions: {\n        queries: {\n          cacheTime: 1000 * 60 * 60 * 24,\n          // 24 hours\n          networkMode: 'offlineFirst',\n          refetchOnWindowFocus: false,\n          retry: 0\n        },\n        mutations: {\n          networkMode: 'offlineFirst'\n        }\n      }\n    }),\n    persister = typeof window !== 'undefined' ? createWebStoragePersister({\n      key: 'wagmi.cache',\n      storage: window.localStorage,\n      serialize,\n      deserialize\n    }) : undefined,\n    ...config\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const client = createClient$1(config);\n  if (persister) persistQueryClient({\n    queryClient,\n    persister,\n    dehydrateOptions: {\n      shouldDehydrateQuery: query => query.cacheTime !== 0\n    }\n  });\n  return Object.assign(client, {\n    queryClient\n  });\n}\n\nconst Context = /*#__PURE__*/React.createContext(undefined);\n\nfunction WagmiConfig(_ref) {\n  let {\n    children,\n    client = createClient()\n  } = _ref; // Attempt to connect on mount\n\n  React.useEffect(() => {\n    (async () => {\n      if (!client.config.autoConnect) return;\n      await client.autoConnect();\n    })(); // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  return /*#__PURE__*/React.createElement(Context.Provider, {\n    value: client\n  }, /*#__PURE__*/React.createElement(QueryClientProvider, {\n    client: client.queryClient\n  }, children));\n}\n\nfunction useClient() {\n  const client = React.useContext(Context);\n  if (!client) throw new Error(['`useClient` must be used within `WagmiConfig`.\\n', 'Read more: https://wagmi.sh/docs/WagmiConfig'].join('\\n'));\n  return client;\n}\n\nfunction useProvider() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const forceUpdate = useForceUpdate();\n  const client = useClient();\n  const provider = React.useRef(getProvider({\n    chainId\n  }));\n  React.useEffect(() => {\n    const unwatch = watchProvider({\n      chainId\n    }, provider_ => {\n      provider.current = provider_;\n      forceUpdate();\n    });\n    return unwatch;\n  }, [chainId, client, forceUpdate]);\n  return provider.current;\n}\n\nfunction useWebSocketProvider() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const forceUpdate = useForceUpdate();\n  const client = useClient();\n  const webSocketProvider = React.useRef(getWebSocketProvider({\n    chainId\n  }));\n  React.useEffect(() => {\n    const unwatch = watchWebSocketProvider({\n      chainId\n    }, webSocketProvider_ => {\n      webSocketProvider.current = webSocketProvider_;\n      forceUpdate();\n    });\n    return unwatch;\n  }, [chainId, client, forceUpdate]);\n  return webSocketProvider.current;\n}\n\nfunction useChainId() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const provider = useProvider({\n    chainId\n  });\n  return provider.network.chainId;\n}\n\nfunction useForceUpdate() {\n  const [, forceUpdate] = React.useReducer(x => x + 1, 0);\n  return forceUpdate;\n}\n\nfunction useQuery(queryKey, queryFn, options_) {\n  const options = {\n    queryKey,\n    queryFn,\n    ...options_\n  };\n  const queryClient = useQueryClient({\n    context: options.context\n  });\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false;\n    }\n  }\n\n  const [observer] = React.useState(() => new QueryObserver(queryClient, defaultedOptions));\n  const {\n    data,\n    dataUpdatedAt,\n    error,\n    errorUpdatedAt,\n    failureCount,\n    fetchStatus,\n    isError,\n    isFetched,\n    isFetchedAfterMount,\n    isFetching,\n    isLoading,\n    isLoadingError,\n    isPaused,\n    isPlaceholderData,\n    isPreviousData,\n    isRefetchError,\n    isRefetching,\n    isStale,\n    isSuccess,\n    refetch,\n    remove,\n    status: status_\n  } = observer.getOptimisticResult(defaultedOptions);\n  useSyncExternalStore(React.useCallback(onStoreChange => isRestoring ? () => undefined : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (defaultedOptions.suspense && isLoading && isFetching && !isRestoring) {\n    throw observer.fetchOptimistic(defaultedOptions).then(_ref => {\n      var _defaultedOptions$onS, _defaultedOptions$onS2;\n\n      let {\n        data\n      } = _ref;\n      (_defaultedOptions$onS = defaultedOptions.onSuccess) === null || _defaultedOptions$onS === void 0 ? void 0 : _defaultedOptions$onS.call(defaultedOptions, data);\n      (_defaultedOptions$onS2 = defaultedOptions.onSettled) === null || _defaultedOptions$onS2 === void 0 ? void 0 : _defaultedOptions$onS2.call(defaultedOptions, data, null);\n    }).catch(error => {\n      var _defaultedOptions$onE, _defaultedOptions$onS3;\n\n      errorResetBoundary.clearReset();\n      (_defaultedOptions$onE = defaultedOptions.onError) === null || _defaultedOptions$onE === void 0 ? void 0 : _defaultedOptions$onE.call(defaultedOptions, error);\n      (_defaultedOptions$onS3 = defaultedOptions.onSettled) === null || _defaultedOptions$onS3 === void 0 ? void 0 : _defaultedOptions$onS3.call(defaultedOptions, undefined, error);\n    });\n  } // Handle error boundary\n\n\n  if (isError && !errorResetBoundary.isReset() && !isFetching && shouldThrowError(defaultedOptions.useErrorBoundary, [error, observer.getCurrentQuery()])) {\n    throw error;\n  }\n\n  const status = status_ === 'loading' && fetchStatus === 'idle' ? 'idle' : status_;\n  const isIdle = status === 'idle';\n  const isLoading_ = status === 'loading' && fetchStatus === 'fetching';\n  const result = {\n    data,\n    error,\n    fetchStatus,\n    isError,\n    isFetched,\n    isFetching,\n    isIdle,\n    isLoading: isLoading_,\n    isRefetching,\n    isSuccess,\n    refetch,\n    status,\n    internal: {\n      dataUpdatedAt,\n      errorUpdatedAt,\n      failureCount,\n      isFetchedAfterMount,\n      isLoadingError,\n      isPaused,\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError,\n      isStale,\n      remove\n    }\n  }; // Handle result property usage tracking\n\n  return !defaultedOptions.notifyOnChangeProps ? trackResult(result, observer) : result;\n}\n\nfunction trackResult(result, observer) {\n  const trackedResult = {};\n  Object.keys(result).forEach(key => {\n    Object.defineProperty(trackedResult, key, {\n      configurable: false,\n      enumerable: true,\n      get: () => {\n        // @ts-expect-error – aware we are mutating private `trackedProps` property.\n        observer.trackedProps.add(key);\n        return result[key];\n      }\n    });\n  });\n  return trackedResult;\n}\n\nfunction shouldThrowError(_useErrorBoundary, params) {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params);\n  }\n\n  return !!_useErrorBoundary;\n}\n\nconst queryKey$b = () => [{\n  entity: 'account'\n}];\n\nconst queryFn$b = () => {\n  const result = getAccount();\n  if (result.address) return result;\n  return null;\n};\n\nfunction useAccount() {\n  let {\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const queryClient = useQueryClient();\n  const accountQuery = useQuery(queryKey$b(), queryFn$b, {\n    staleTime: 0,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n  React.useEffect(() => {\n    const unwatch = watchAccount(data => {\n      queryClient.setQueryData(queryKey$b(), data !== null && data !== void 0 && data.address ? data : null);\n    });\n    return unwatch;\n  }, [queryClient]);\n  return accountQuery;\n}\n\nconst queryKey$a = _ref => {\n  let {\n    chainId\n  } = _ref;\n  return [{\n    entity: 'blockNumber',\n    chainId\n  }];\n};\n\nconst queryFn$a = _ref2 => {\n  let {\n    queryKey: [{\n      chainId\n    }]\n  } = _ref2;\n  return fetchBlockNumber({\n    chainId\n  });\n};\n\nfunction useBlockNumber() {\n  let {\n    cacheTime = 0,\n    chainId: chainId_,\n    enabled = true,\n    staleTime,\n    suspense,\n    watch = false,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const provider = useProvider();\n  const webSocketProvider = useWebSocketProvider();\n  const queryClient = useQueryClient();\n  React.useEffect(() => {\n    if (!watch) return;\n\n    const listener = blockNumber => {\n      // Just to be safe in case the provider implementation\n      // calls the event callback after .off() has been called\n      queryClient.setQueryData(queryKey$a({\n        chainId\n      }), blockNumber);\n    };\n\n    const provider_ = webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider;\n    provider_.on('block', listener);\n    return () => {\n      provider_.off('block', listener);\n    };\n  }, [chainId, provider, queryClient, watch, webSocketProvider]);\n  return useQuery(queryKey$a({\n    chainId\n  }), queryFn$a, {\n    cacheTime,\n    enabled,\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst queryKey$9 = _ref => {\n  let {\n    chainId,\n    formatUnits\n  } = _ref;\n  return [{\n    entity: 'feeData',\n    chainId,\n    formatUnits\n  }];\n};\n\nconst queryFn$9 = _ref2 => {\n  let {\n    queryKey: [{\n      chainId,\n      formatUnits\n    }]\n  } = _ref2;\n  return fetchFeeData({\n    chainId,\n    formatUnits\n  });\n};\n\nfunction useFeeData() {\n  let {\n    cacheTime,\n    chainId: chainId_,\n    enabled = true,\n    formatUnits = 'wei',\n    staleTime,\n    suspense,\n    watch,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const feeDataQuery = useQuery(queryKey$9({\n    chainId,\n    formatUnits\n  }), queryFn$9, {\n    cacheTime,\n    enabled,\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n  const {\n    data: blockNumber\n  } = useBlockNumber({\n    watch\n  });\n  React.useEffect(() => {\n    if (!enabled) return;\n    if (!watch) return;\n    if (!blockNumber) return;\n    feeDataQuery.refetch(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [blockNumber]);\n  return feeDataQuery;\n}\n\nconst queryKey$8 = _ref => {\n  let {\n    addressOrName,\n    chainId,\n    formatUnits,\n    token\n  } = _ref;\n  return [{\n    entity: 'balance',\n    addressOrName,\n    chainId,\n    formatUnits,\n    token\n  }];\n};\n\nconst queryFn$8 = _ref2 => {\n  let {\n    queryKey: [{\n      addressOrName,\n      chainId,\n      formatUnits,\n      token\n    }]\n  } = _ref2;\n  if (!addressOrName) throw new Error('address is required');\n  return fetchBalance({\n    addressOrName,\n    chainId,\n    formatUnits,\n    token\n  });\n};\n\nfunction useBalance() {\n  let {\n    addressOrName,\n    cacheTime,\n    chainId: chainId_,\n    enabled = true,\n    formatUnits = 'ether',\n    staleTime,\n    suspense,\n    token,\n    watch,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const balanceQuery = useQuery(queryKey$8({\n    addressOrName,\n    chainId,\n    formatUnits,\n    token\n  }), queryFn$8, {\n    cacheTime,\n    enabled: Boolean(enabled && addressOrName),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n  const {\n    data: blockNumber\n  } = useBlockNumber({\n    watch\n  });\n  React.useEffect(() => {\n    if (!enabled) return;\n    if (!watch) return;\n    if (!blockNumber) return;\n    if (!addressOrName) return;\n    balanceQuery.refetch(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [blockNumber]);\n  return balanceQuery;\n}\n\nconst mutationKey$6 = args => [{\n  entity: 'connect',\n  ...args\n}];\n\nconst mutationFn$5 = args => {\n  const {\n    connector,\n    chainId\n  } = args;\n  if (!connector) throw new Error('connector is required');\n  return connect({\n    connector,\n    chainId\n  });\n};\n\nfunction useConnect() {\n  let {\n    chainId,\n    connector,\n    onBeforeConnect,\n    onConnect,\n    onError,\n    onSettled\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const forceUpdate = useForceUpdate();\n  const client = useClient();\n  const {\n    data,\n    error,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey$6({\n    connector,\n    chainId\n  }), mutationFn$5, {\n    onError,\n    onMutate: onBeforeConnect,\n    onSettled,\n    onSuccess: onConnect\n  });\n  React.useEffect(() => {\n    // Trigger update when connector or status change\n    const unsubscribe = client.subscribe(state => ({\n      connector: state.connector,\n      connectors: state.connectors,\n      status: state.status\n    }), forceUpdate, {\n      equalityFn: (selected, previous) => selected.connector === previous.connector && selected.connectors === previous.connectors && selected.status === previous.status\n    });\n    return unsubscribe;\n  }, [client, forceUpdate]);\n  const connect = React.useCallback(connectorOrArgs => {\n    let config;\n\n    if (connectorOrArgs instanceof Connector) {\n      const connector_ = connectorOrArgs;\n      config = {\n        chainId,\n        connector: connector_ !== null && connector_ !== void 0 ? connector_ : connector\n      };\n    } else {\n      var _args$chainId, _args$connector;\n\n      const args = connectorOrArgs;\n      config = {\n        chainId: (_args$chainId = args === null || args === void 0 ? void 0 : args.chainId) !== null && _args$chainId !== void 0 ? _args$chainId : chainId,\n        connector: (_args$connector = args === null || args === void 0 ? void 0 : args.connector) !== null && _args$connector !== void 0 ? _args$connector : connector\n      };\n    }\n\n    return mutate(config);\n  }, [chainId, connector, mutate]);\n  const connectAsync = React.useCallback(connectorOrArgs => {\n    let config;\n\n    if (connectorOrArgs instanceof Connector) {\n      const connector_ = connectorOrArgs;\n      config = {\n        chainId,\n        connector: connector_ !== null && connector_ !== void 0 ? connector_ : connector\n      };\n    } else {\n      var _args$chainId2, _args$connector2;\n\n      const args = connectorOrArgs;\n      config = {\n        chainId: (_args$chainId2 = args === null || args === void 0 ? void 0 : args.chainId) !== null && _args$chainId2 !== void 0 ? _args$chainId2 : chainId,\n        connector: (_args$connector2 = args === null || args === void 0 ? void 0 : args.connector) !== null && _args$connector2 !== void 0 ? _args$connector2 : connector\n      };\n    }\n\n    return mutateAsync(config);\n  }, [chainId, connector, mutateAsync]);\n  let status_;\n  if (client.status === 'reconnecting') status_ = 'reconnecting';else if (status === 'loading' || client.status === 'connecting') status_ = 'connecting';else if (client.connector) status_ = 'connected';else if (!client.connector || status === 'success') status_ = 'disconnected';else status_ = status;\n  return {\n    activeConnector: client.connector,\n    connect,\n    connectAsync,\n    connectors: client.connectors,\n    data,\n    error,\n    isConnected: status_ === 'connected',\n    isConnecting: status_ === 'connecting',\n    isDisconnected: status_ === 'disconnected',\n    isError: status === 'error',\n    isIdle: status_ === 'idle',\n    isReconnecting: status_ === 'reconnecting',\n    pendingConnector: variables === null || variables === void 0 ? void 0 : variables.connector,\n    reset,\n    status: status_\n  };\n}\n\nconst mutationKey$5 = [{\n  entity: 'disconnect'\n}];\n\nconst mutationFn$4 = () => disconnect();\n\nfunction useDisconnect() {\n  let {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const queryClient = useQueryClient();\n  const {\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate: disconnect,\n    mutateAsync: disconnectAsync,\n    reset,\n    status\n  } = useMutation(mutationKey$5, mutationFn$4, { ...(onError ? {\n      onError(error, _variables, context) {\n        onError(error, context);\n      }\n\n    } : {}),\n    onMutate,\n    ...(onSettled ? {\n      onSettled(_data, error, _variables, context) {\n        onSettled(error, context);\n      }\n\n    } : {}),\n\n    onSuccess(_data, _variables, context) {\n      // Clear account cache\n      queryClient.removeQueries(queryKey$b()); // Pass on arguments\n\n      onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(context);\n    }\n\n  });\n  return {\n    disconnect,\n    disconnectAsync,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    status\n  };\n}\n\nconst mutationKey$4 = args => [{\n  entity: 'switchNetwork',\n  ...args\n}];\n\nconst mutationFn$3 = args => {\n  const {\n    chainId\n  } = args;\n  if (!chainId) throw new Error('chainId is required');\n  return switchNetwork({\n    chainId\n  });\n};\n\nfunction useNetwork() {\n  var _network$current$chai;\n\n  let {\n    chainId,\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const forceUpdate = useForceUpdate();\n  const network = React.useRef(getNetwork());\n  const client = useClient();\n  const queryClient = useQueryClient();\n  const connector = client.connector;\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey$4({\n    chainId\n  }), mutationFn$3, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  React.useEffect(() => {\n    const unwatch = watchNetwork(data => {\n      network.current = data;\n      forceUpdate();\n    });\n    return unwatch;\n  }, [forceUpdate, queryClient]);\n  const switchNetwork_ = React.useCallback(chainId_ => mutate({\n    chainId: chainId_ !== null && chainId_ !== void 0 ? chainId_ : chainId\n  }), [chainId, mutate]);\n  const switchNetworkAsync_ = React.useCallback(chainId_ => mutateAsync({\n    chainId: chainId_ !== null && chainId_ !== void 0 ? chainId_ : chainId\n  }), [chainId, mutateAsync]);\n  return {\n    activeChain: network.current.chain,\n    chains: (_network$current$chai = network.current.chains) !== null && _network$current$chai !== void 0 ? _network$current$chai : [],\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    pendingChainId: variables === null || variables === void 0 ? void 0 : variables.chainId,\n    reset,\n    status,\n    switchNetwork: connector !== null && connector !== void 0 && connector.switchChain ? switchNetwork_ : undefined,\n    switchNetworkAsync: connector !== null && connector !== void 0 && connector.switchChain ? switchNetworkAsync_ : undefined,\n    variables\n  };\n}\n\nconst queryKey$7 = () => [{\n  entity: 'signer'\n}];\n\nconst queryFn$7 = () => fetchSigner();\n\nfunction useSigner() {\n  let {\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const signerQuery = useQuery(queryKey$7(), queryFn$7, {\n    cacheTime: 0,\n    staleTime: 0,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n  const queryClient = useQueryClient();\n  React.useEffect(() => {\n    const unwatch = watchSigner(signer => queryClient.setQueryData(queryKey$7(), signer));\n    return unwatch;\n  }, [queryClient]);\n  return signerQuery;\n}\n\nconst mutationKey$3 = args => [{\n  entity: 'signMessage',\n  ...args\n}];\n\nconst mutationFn$2 = args => {\n  const {\n    message\n  } = args;\n  if (!message) throw new Error('message is required');\n  return signMessage({\n    message\n  });\n};\n\nfunction useSignMessage() {\n  let {\n    message,\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey$3({\n    message\n  }), mutationFn$2, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  const signMessage = React.useCallback(args => mutate(args || {\n    message\n  }), [message, mutate]);\n  const signMessageAsync = React.useCallback(args => mutateAsync(args || {\n    message\n  }), [message, mutateAsync]);\n  return {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    signMessage,\n    signMessageAsync,\n    status,\n    variables\n  };\n}\n\nconst mutationKey$2 = args => [{\n  entity: 'signTypedData',\n  ...args\n}];\n\nconst mutationFn$1 = args => {\n  const {\n    domain,\n    types,\n    value\n  } = args;\n  if (!domain || !types || !value) throw new Error('domain, types, and value are all required');\n  return signTypedData({\n    domain,\n    types,\n    value\n  });\n};\n\nfunction useSignTypedData() {\n  let {\n    domain,\n    types,\n    value,\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey$2({\n    domain,\n    types,\n    value\n  }), mutationFn$1, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  const signTypedData = React.useCallback(args => mutate(args || {\n    domain,\n    types,\n    value\n  }), [domain, types, value, mutate]);\n  const signTypedDataAsync = React.useCallback(args => mutateAsync(args || {\n    domain,\n    types,\n    value\n  }), [domain, types, value, mutateAsync]);\n  return {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    signTypedData,\n    signTypedDataAsync,\n    status,\n    variables\n  };\n}\n\nconst useContract = _ref => {\n  let {\n    addressOrName,\n    contractInterface,\n    signerOrProvider\n  } = _ref;\n  return React.useMemo(() => {\n    return getContract({\n      addressOrName,\n      contractInterface,\n      signerOrProvider\n    });\n  }, [addressOrName, contractInterface, signerOrProvider]);\n};\n\nconst useContractEvent = function (contractConfig, eventName, listener) {\n  let {\n    chainId,\n    once\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const provider = useProvider({\n    chainId\n  });\n  const webSocketProvider = useWebSocketProvider({\n    chainId\n  });\n  const contract = useContract({\n    signerOrProvider: webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider,\n    ...contractConfig\n  });\n  const listenerRef = React.useRef(listener);\n  listenerRef.current = listener;\n  React.useEffect(() => {\n    const handler = function () {\n      for (var _len = arguments.length, event = new Array(_len), _key = 0; _key < _len; _key++) {\n        event[_key] = arguments[_key];\n      }\n\n      return listenerRef.current(event);\n    };\n\n    const contract_ = contract;\n    if (once) contract_.once(eventName, handler);else contract_.on(eventName, handler);\n    return () => {\n      contract_.off(eventName, handler);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [contract, eventName]);\n};\n\nconst queryKey$6 = _ref => {\n  let [contractConfig, functionName, {\n    args,\n    chainId,\n    overrides\n  }, {\n    blockNumber\n  }] = _ref;\n  return [{\n    entity: 'readContract',\n    args,\n    blockNumber,\n    chainId,\n    contractConfig,\n    functionName,\n    overrides\n  }];\n};\n\nconst queryFn$6 = _ref2 => {\n  let {\n    queryKey: [{\n      args,\n      chainId,\n      contractConfig,\n      functionName,\n      overrides\n    }]\n  } = _ref2;\n  return readContract(contractConfig, functionName, {\n    args,\n    chainId,\n    overrides\n  });\n};\n\nfunction useContractRead(contractConfig, functionName) {\n  let {\n    args,\n    chainId: chainId_,\n    overrides,\n    cacheOnBlock = false,\n    cacheTime,\n    enabled: enabled_ = true,\n    staleTime,\n    suspense,\n    watch,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const {\n    data: blockNumber\n  } = useBlockNumber({\n    enabled: watch || cacheOnBlock,\n    watch\n  });\n  const queryKey_ = React.useMemo(() => queryKey$6([contractConfig, functionName, {\n    args,\n    chainId,\n    overrides\n  }, {\n    blockNumber: cacheOnBlock ? blockNumber : undefined\n  }]), [args, blockNumber, cacheOnBlock, chainId, contractConfig, functionName, overrides]);\n  const enabled = React.useMemo(() => {\n    let enabled = Boolean(enabled_ && contractConfig && functionName);\n    if (cacheOnBlock) enabled = Boolean(enabled && blockNumber);\n    return enabled;\n  }, [blockNumber, cacheOnBlock, contractConfig, enabled_, functionName]);\n  const client = useQueryClient();\n  React.useEffect(() => {\n    if (enabled) {\n      const unwatch = watchReadContract(contractConfig, functionName, {\n        args,\n        chainId,\n        overrides,\n        listenToBlock: watch && !cacheOnBlock\n      }, result => client.setQueryData(queryKey_, result));\n      return unwatch;\n    }\n  }, [args, cacheOnBlock, chainId, client, contractConfig, enabled, functionName, overrides, queryKey_, watch]);\n  return useQuery(queryKey_, queryFn$6, {\n    cacheTime,\n    enabled,\n    select: data => parseContractResult({\n      contractInterface: contractConfig.contractInterface,\n      data,\n      functionName\n    }),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst mutationKey$1 = _ref => {\n  let [contractConfig, functionName, {\n    args,\n    overrides\n  }] = _ref;\n  return [{\n    entity: 'writeContract',\n    args,\n    contractConfig,\n    functionName,\n    overrides\n  }];\n};\n\nfunction useContractWrite(contractConfig, functionName) {\n  let {\n    args,\n    overrides,\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey$1([contractConfig, functionName, {\n    args,\n    overrides\n  }]), _ref2 => {\n    let {\n      args,\n      overrides\n    } = _ref2;\n    return writeContract(contractConfig, functionName, {\n      args,\n      overrides\n    });\n  }, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  const write = React.useCallback(overrideConfig => mutate(overrideConfig || {\n    args,\n    overrides\n  }), [args, mutate, overrides]);\n  const writeAsync = React.useCallback(overrideConfig => mutateAsync(overrideConfig || {\n    args,\n    overrides\n  }), [args, mutateAsync, overrides]);\n  return {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    status,\n    variables,\n    write,\n    writeAsync\n  };\n}\n\nconst queryKey$5 = _ref => {\n  let {\n    address,\n    chainId,\n    formatUnits\n  } = _ref;\n  return [{\n    entity: 'token',\n    address,\n    chainId,\n    formatUnits\n  }];\n};\n\nconst queryFn$5 = _ref2 => {\n  let {\n    queryKey: [{\n      address,\n      chainId,\n      formatUnits\n    }]\n  } = _ref2;\n  if (!address) throw new Error('address is required');\n  return fetchToken({\n    address,\n    chainId,\n    formatUnits\n  });\n};\n\nfunction useToken() {\n  let {\n    address,\n    chainId: chainId_,\n    formatUnits = 'ether',\n    cacheTime,\n    enabled = true,\n    staleTime = 1000 * 60 * 60 * 24,\n    // 24 hours\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$5({\n    address,\n    chainId,\n    formatUnits\n  }), queryFn$5, {\n    cacheTime,\n    enabled: Boolean(enabled && address),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst queryKey$4 = _ref => {\n  let {\n    chainId,\n    name\n  } = _ref;\n  return [{\n    entity: 'ensAddress',\n    chainId,\n    name\n  }];\n};\n\nconst queryFn$4 = _ref2 => {\n  let {\n    queryKey: [{\n      chainId,\n      name\n    }]\n  } = _ref2;\n  if (!name) throw new Error('name is required');\n  return fetchEnsAddress({\n    chainId,\n    name\n  });\n};\n\nfunction useEnsAddress() {\n  let {\n    cacheTime,\n    chainId: chainId_,\n    enabled = true,\n    name,\n    staleTime = 1000 * 60 * 60 * 24,\n    // 24 hours\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$4({\n    chainId,\n    name\n  }), queryFn$4, {\n    cacheTime,\n    enabled: Boolean(enabled && chainId && name),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst queryKey$3 = _ref => {\n  let {\n    addressOrName,\n    chainId\n  } = _ref;\n  return [{\n    entity: 'ensAvatar',\n    addressOrName,\n    chainId\n  }];\n};\n\nconst queryFn$3 = _ref2 => {\n  let {\n    queryKey: [{\n      addressOrName,\n      chainId\n    }]\n  } = _ref2;\n  if (!addressOrName) throw new Error('addressOrName is required');\n  return fetchEnsAvatar({\n    addressOrName,\n    chainId\n  });\n};\n\nfunction useEnsAvatar() {\n  let {\n    addressOrName,\n    cacheTime,\n    chainId: chainId_,\n    enabled = true,\n    staleTime = 1000 * 60 * 60 * 24,\n    // 24 hours\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$3({\n    addressOrName,\n    chainId\n  }), queryFn$3, {\n    cacheTime,\n    enabled: Boolean(enabled && addressOrName && chainId),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst queryKey$2 = _ref => {\n  let {\n    address,\n    chainId\n  } = _ref;\n  return [{\n    entity: 'ensName',\n    address,\n    chainId\n  }];\n};\n\nconst queryFn$2 = _ref2 => {\n  let {\n    queryKey: [{\n      address,\n      chainId\n    }]\n  } = _ref2;\n  if (!address) throw new Error('address is required');\n  return fetchEnsName({\n    address,\n    chainId\n  });\n};\n\nfunction useEnsName() {\n  let {\n    address,\n    cacheTime,\n    chainId: chainId_,\n    enabled = true,\n    staleTime = 1000 * 60 * 60 * 24,\n    // 24 hours\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$2({\n    address,\n    chainId\n  }), queryFn$2, {\n    cacheTime,\n    enabled: Boolean(enabled && address && chainId),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst queryKey$1 = _ref => {\n  let {\n    chainId,\n    name\n  } = _ref;\n  return [{\n    entity: 'ensResolver',\n    chainId,\n    name\n  }];\n};\n\nconst queryFn$1 = _ref2 => {\n  let {\n    queryKey: [{\n      chainId,\n      name\n    }]\n  } = _ref2;\n  if (!name) throw new Error('name is required');\n  return fetchEnsResolver({\n    chainId,\n    name\n  });\n};\n\nfunction useEnsResolver() {\n  let {\n    cacheTime,\n    chainId: chainId_,\n    enabled = true,\n    name,\n    staleTime = 1000 * 60 * 60 * 24,\n    // 24 hours\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$1({\n    chainId,\n    name\n  }), queryFn$1, {\n    cacheTime,\n    enabled: Boolean(enabled && chainId && name),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst mutationKey = args => [{\n  entity: 'sendTransaction',\n  ...args\n}];\n\nconst mutationFn = args => {\n  const {\n    request\n  } = args;\n  if (!request) throw new Error('request is required');\n  return sendTransaction({\n    request\n  });\n};\n\nfunction useSendTransaction() {\n  let {\n    request,\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey({\n    request\n  }), mutationFn, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  const sendTransaction = React.useCallback(args => mutate(args || {\n    request\n  }), [mutate, request]);\n  const sendTransactionAsync = React.useCallback(args => mutateAsync(args || {\n    request\n  }), [mutateAsync, request]);\n  return {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    sendTransaction,\n    sendTransactionAsync,\n    status,\n    variables\n  };\n}\n\nconst queryKey = _ref => {\n  let {\n    confirmations,\n    chainId,\n    hash,\n    timeout,\n    wait\n  } = _ref;\n  return [{\n    entity: 'waitForTransaction',\n    confirmations,\n    chainId,\n    hash,\n    timeout,\n    wait\n  }];\n};\n\nconst queryFn = _ref2 => {\n  let {\n    queryKey: [{\n      chainId,\n      confirmations,\n      hash,\n      timeout,\n      wait\n    }]\n  } = _ref2;\n  return waitForTransaction({\n    chainId,\n    confirmations,\n    hash,\n    timeout,\n    wait\n  });\n};\n\nfunction useWaitForTransaction() {\n  let {\n    chainId: chainId_,\n    confirmations,\n    hash,\n    timeout,\n    wait,\n    cacheTime,\n    enabled = true,\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey({\n    chainId,\n    confirmations,\n    hash,\n    timeout,\n    wait\n  }), queryFn, {\n    cacheTime,\n    enabled: Boolean(enabled && (hash || wait)),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nexport { Context, WagmiConfig, WagmiConfig as WagmiProvider, createClient, deserialize, serialize, useAccount, useBalance, useBlockNumber, useClient, useConnect, useContract, useContractEvent, useContractRead, useContractWrite, useDisconnect, useEnsAddress, useEnsAvatar, useEnsName, useEnsResolver, useFeeData, useNetwork, useProvider, useQuery, useSendTransaction, useSignMessage, useSignTypedData, useSigner, useToken, useWaitForTransaction, useWebSocketProvider };","map":{"version":3,"names":["React","createClient","createClient$1","getProvider","watchProvider","getWebSocketProvider","watchWebSocketProvider","watchAccount","getAccount","fetchBlockNumber","fetchFeeData","fetchBalance","Connector","connect","disconnect","getNetwork","watchNetwork","switchNetwork","watchSigner","fetchSigner","signMessage","signTypedData","getContract","watchReadContract","readContract","writeContract","fetchToken","fetchEnsAddress","fetchEnsAvatar","fetchEnsName","fetchEnsResolver","sendTransaction","waitForTransaction","AddChainError","ChainNotConfiguredError","Client","ConnectorAlreadyConnectedError","ConnectorNotFoundError","ProviderRpcError","ResourceUnavailableError","RpcError","SwitchChainError","SwitchChainNotSupportedError","UserRejectedRequestError","alchemyRpcUrls","allChains","chain","chainId","configureChains","createStorage","defaultChains","defaultL2Chains","erc20ABI","erc721ABI","etherscanBlockExplorers","infuraRpcUrls","QueryClient","QueryClientProvider","useQueryClient","useIsRestoring","useQueryErrorResetBoundary","notifyManager","QueryObserver","useMutation","persistQueryClient","createWebStoragePersister","BigNumber","Contract","useSyncExternalStore","findAndReplace","cacheRef","_ref","find","replace","Array","isArray","map","item","Object","entries","reduce","curr","_ref2","key","value","deserialize","cachedString","cache","JSON","parse","deserializedCacheWithBigNumbers","data","type","from","hex","isPlainArray","keys","length","parseContractResult","contractInterface","functionName","_fragment$outputs","_fragment$outputs$","_fragment$outputs2","_fragment$outputs2$","iface","getInterface","fragment","getFunction","outputs","baseType","data_","encodedResult","encodeFunctionResult","decodedResult","decodeFunctionResult","getReferenceKey","cutoff","slice","join","getCutoff","array","index","createReplacer","replacer","circularReplacer","hasReplacer","hasCircularReplacer","thisCutoff","splice","valueCutoff","call","concat","serialize","indent","stringify","undefined","queryClient","defaultOptions","queries","cacheTime","networkMode","refetchOnWindowFocus","retry","mutations","persister","window","storage","localStorage","config","arguments","client","dehydrateOptions","shouldDehydrateQuery","query","assign","Context","createContext","WagmiConfig","children","useEffect","autoConnect","createElement","Provider","useClient","useContext","Error","useProvider","forceUpdate","useForceUpdate","provider","useRef","unwatch","provider_","current","useWebSocketProvider","webSocketProvider","webSocketProvider_","useChainId","network","useReducer","x","useQuery","queryKey","queryFn","options_","options","context","isRestoring","errorResetBoundary","defaultedOptions","defaultQueryOptions","_optimisticResults","onError","batchCalls","onSuccess","onSettled","suspense","staleTime","useErrorBoundary","isReset","retryOnMount","observer","useState","dataUpdatedAt","error","errorUpdatedAt","failureCount","fetchStatus","isError","isFetched","isFetchedAfterMount","isFetching","isLoading","isLoadingError","isPaused","isPlaceholderData","isPreviousData","isRefetchError","isRefetching","isStale","isSuccess","refetch","remove","status","status_","getOptimisticResult","useCallback","onStoreChange","subscribe","getCurrentResult","clearReset","setOptions","listeners","fetchOptimistic","then","_defaultedOptions$onS","_defaultedOptions$onS2","catch","_defaultedOptions$onE","_defaultedOptions$onS3","shouldThrowError","getCurrentQuery","isIdle","isLoading_","result","internal","notifyOnChangeProps","trackResult","trackedResult","forEach","defineProperty","configurable","enumerable","get","trackedProps","add","_useErrorBoundary","params","queryKey$b","entity","queryFn$b","address","useAccount","accountQuery","setQueryData","queryKey$a","queryFn$a","useBlockNumber","chainId_","enabled","watch","listener","blockNumber","on","off","queryKey$9","formatUnits","queryFn$9","useFeeData","feeDataQuery","queryKey$8","addressOrName","token","queryFn$8","useBalance","balanceQuery","Boolean","mutationKey$6","args","mutationFn$5","connector","useConnect","onBeforeConnect","onConnect","mutate","mutateAsync","reset","variables","onMutate","unsubscribe","state","connectors","equalityFn","selected","previous","connectorOrArgs","connector_","_args$chainId","_args$connector","connectAsync","_args$chainId2","_args$connector2","activeConnector","isConnected","isConnecting","isDisconnected","isReconnecting","pendingConnector","mutationKey$5","mutationFn$4","useDisconnect","disconnectAsync","_variables","_data","removeQueries","mutationKey$4","mutationFn$3","useNetwork","_network$current$chai","switchNetwork_","switchNetworkAsync_","activeChain","chains","pendingChainId","switchChain","switchNetworkAsync","queryKey$7","queryFn$7","useSigner","signerQuery","signer","mutationKey$3","mutationFn$2","message","useSignMessage","signMessageAsync","mutationKey$2","mutationFn$1","domain","types","useSignTypedData","signTypedDataAsync","useContract","signerOrProvider","useMemo","useContractEvent","contractConfig","eventName","once","contract","listenerRef","handler","_len","event","_key","contract_","queryKey$6","overrides","queryFn$6","useContractRead","cacheOnBlock","enabled_","queryKey_","listenToBlock","select","mutationKey$1","useContractWrite","write","overrideConfig","writeAsync","queryKey$5","queryFn$5","useToken","queryKey$4","name","queryFn$4","useEnsAddress","queryKey$3","queryFn$3","useEnsAvatar","queryKey$2","queryFn$2","useEnsName","queryKey$1","queryFn$1","useEnsResolver","mutationKey","mutationFn","request","useSendTransaction","sendTransactionAsync","confirmations","hash","timeout","wait","useWaitForTransaction","WagmiProvider"],"sources":["/home/king-longs/Desktop/final/node_modules/wagmi/dist/wagmi.esm.js"],"sourcesContent":["import * as React from 'react';\nimport { createClient as createClient$1, getProvider, watchProvider, getWebSocketProvider, watchWebSocketProvider, watchAccount, getAccount, fetchBlockNumber, fetchFeeData, fetchBalance, Connector, connect, disconnect, getNetwork, watchNetwork, switchNetwork, watchSigner, fetchSigner, signMessage, signTypedData, getContract, watchReadContract, readContract, writeContract, fetchToken, fetchEnsAddress, fetchEnsAvatar, fetchEnsName, fetchEnsResolver, sendTransaction, waitForTransaction } from '@wagmi/core';\nexport { AddChainError, ChainNotConfiguredError, Client, Connector, ConnectorAlreadyConnectedError, ConnectorNotFoundError, ProviderRpcError, ResourceUnavailableError, RpcError, SwitchChainError, SwitchChainNotSupportedError, UserRejectedRequestError, alchemyRpcUrls, allChains, chain, chainId, configureChains, createStorage, defaultChains, defaultL2Chains, erc20ABI, erc721ABI, etherscanBlockExplorers, infuraRpcUrls } from '@wagmi/core';\nimport { QueryClient, QueryClientProvider, useQueryClient, useIsRestoring, useQueryErrorResetBoundary, notifyManager, QueryObserver, useMutation } from 'react-query';\nimport { persistQueryClient } from 'react-query/persistQueryClient';\nimport { createWebStoragePersister } from 'react-query/createWebStoragePersister';\nimport { BigNumber, Contract } from 'ethers/lib/ethers';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\n\nconst findAndReplace = (cacheRef, _ref) => {\n  let {\n    find,\n    replace\n  } = _ref;\n\n  if (cacheRef && find(cacheRef)) {\n    return replace(cacheRef);\n  }\n\n  if (typeof cacheRef !== 'object') {\n    return cacheRef;\n  }\n\n  if (Array.isArray(cacheRef)) {\n    return cacheRef.map(item => findAndReplace(item, {\n      find,\n      replace\n    }));\n  }\n\n  if (cacheRef instanceof Object) {\n    return Object.entries(cacheRef).reduce((curr, _ref2) => {\n      let [key, value] = _ref2;\n      return { ...curr,\n        [key]: findAndReplace(value, {\n          find,\n          replace\n        })\n      };\n    }, {});\n  }\n\n  return cacheRef;\n};\n\nfunction deserialize(cachedString) {\n  const cache = JSON.parse(cachedString);\n  const deserializedCacheWithBigNumbers = findAndReplace(cache, {\n    find: data => data.type === 'BigNumber',\n    replace: data => BigNumber.from(data.hex)\n  });\n  return deserializedCacheWithBigNumbers;\n}\n\nfunction isPlainArray(value) {\n  return Array.isArray(value) && Object.keys(value).length === value.length;\n}\n\nfunction parseContractResult(_ref) {\n  let {\n    contractInterface,\n    data,\n    functionName\n  } = _ref;\n\n  if (data && isPlainArray(data)) {\n    var _fragment$outputs, _fragment$outputs$, _fragment$outputs2, _fragment$outputs2$;\n\n    const iface = Contract.getInterface(contractInterface);\n    const fragment = iface.getFunction(functionName);\n    const isArray = (fragment === null || fragment === void 0 ? void 0 : (_fragment$outputs = fragment.outputs) === null || _fragment$outputs === void 0 ? void 0 : (_fragment$outputs$ = _fragment$outputs[0]) === null || _fragment$outputs$ === void 0 ? void 0 : _fragment$outputs$.baseType) === 'array' || (fragment === null || fragment === void 0 ? void 0 : (_fragment$outputs2 = fragment.outputs) === null || _fragment$outputs2 === void 0 ? void 0 : (_fragment$outputs2$ = _fragment$outputs2[0]) === null || _fragment$outputs2$ === void 0 ? void 0 : _fragment$outputs2$.baseType) === 'tuple';\n    const data_ = isArray ? [data] : data;\n    const encodedResult = iface.encodeFunctionResult(functionName, data_);\n    const decodedResult = iface.decodeFunctionResult(functionName, encodedResult);\n    return isArray ? decodedResult[0] : decodedResult;\n  }\n\n  return data;\n}\n\n/**\n * @function getReferenceKey\n *\n * @description\n * get the reference key for the circular value\n *\n * @param keys the keys to build the reference key from\n * @param cutoff the maximum number of keys to include\n * @returns the reference key\n */\nfunction getReferenceKey(keys, cutoff) {\n  return keys.slice(0, cutoff).join('.') || '.';\n}\n/**\n * @function getCutoff\n *\n * @description\n * faster `Array.prototype.indexOf` implementation build for slicing / splicing\n *\n * @param array the array to match the value in\n * @param value the value to match\n * @returns the matching index, or -1\n */\n\n\nfunction getCutoff(array, value) {\n  const {\n    length\n  } = array;\n\n  for (let index = 0; index < length; ++index) {\n    if (array[index] === value) {\n      return index + 1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * @function createReplacer\n *\n * @description\n * create a replacer method that handles circular values\n *\n * @param [replacer] a custom replacer to use for non-circular values\n * @param [circularReplacer] a custom replacer to use for circular methods\n * @returns the value to stringify\n */\nfunction createReplacer(replacer, circularReplacer) {\n  const hasReplacer = typeof replacer === 'function';\n  const hasCircularReplacer = typeof circularReplacer === 'function';\n  const cache = [];\n  const keys = [];\n  return function replace(key, value) {\n    if (typeof value === 'object') {\n      if (cache.length) {\n        const thisCutoff = getCutoff(cache, this);\n\n        if (thisCutoff === 0) {\n          cache[cache.length] = this;\n        } else {\n          cache.splice(thisCutoff);\n          keys.splice(thisCutoff);\n        }\n\n        keys[keys.length] = key;\n        const valueCutoff = getCutoff(cache, value);\n\n        if (valueCutoff !== 0) {\n          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : \"[ref=\".concat(getReferenceKey(keys, valueCutoff), \"]\");\n        }\n      } else {\n        cache[0] = value;\n        keys[0] = key;\n      }\n    }\n\n    return hasReplacer ? replacer.call(this, key, value) : value;\n  };\n}\n/**\n * @function stringify\n *\n * @description\n * strinigifer that handles circular values\n * Forked from https://github.com/planttheidea/fast-stringify\n *\n * @param value to stringify\n * @param [replacer] a custom replacer function for handling standard values\n * @param [indent] the number of spaces to indent the output by\n * @param [circularReplacer] a custom replacer function for handling circular values\n * @returns the stringified output\n */\n\n\nfunction serialize(value, replacer, indent, circularReplacer) {\n  return JSON.stringify(value, createReplacer(replacer, circularReplacer), indent !== null && indent !== void 0 ? indent : undefined);\n}\n\nfunction createClient() {\n  let {\n    queryClient = new QueryClient({\n      defaultOptions: {\n        queries: {\n          cacheTime: 1000 * 60 * 60 * 24,\n          // 24 hours\n          networkMode: 'offlineFirst',\n          refetchOnWindowFocus: false,\n          retry: 0\n        },\n        mutations: {\n          networkMode: 'offlineFirst'\n        }\n      }\n    }),\n    persister = typeof window !== 'undefined' ? createWebStoragePersister({\n      key: 'wagmi.cache',\n      storage: window.localStorage,\n      serialize,\n      deserialize\n    }) : undefined,\n    ...config\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const client = createClient$1(config);\n  if (persister) persistQueryClient({\n    queryClient,\n    persister,\n    dehydrateOptions: {\n      shouldDehydrateQuery: query => query.cacheTime !== 0\n    }\n  });\n  return Object.assign(client, {\n    queryClient\n  });\n}\nconst Context = /*#__PURE__*/React.createContext(undefined);\nfunction WagmiConfig(_ref) {\n  let {\n    children,\n    client = createClient()\n  } = _ref;\n  // Attempt to connect on mount\n  React.useEffect(() => {\n\n    (async () => {\n      if (!client.config.autoConnect) return;\n      await client.autoConnect();\n    })(); // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  return /*#__PURE__*/React.createElement(Context.Provider, {\n    value: client\n  }, /*#__PURE__*/React.createElement(QueryClientProvider, {\n    client: client.queryClient\n  }, children));\n}\nfunction useClient() {\n  const client = React.useContext(Context);\n  if (!client) throw new Error(['`useClient` must be used within `WagmiConfig`.\\n', 'Read more: https://wagmi.sh/docs/WagmiConfig'].join('\\n'));\n  return client;\n}\n\nfunction useProvider() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const forceUpdate = useForceUpdate();\n  const client = useClient();\n  const provider = React.useRef(getProvider({\n    chainId\n  }));\n  React.useEffect(() => {\n    const unwatch = watchProvider({\n      chainId\n    }, provider_ => {\n      provider.current = provider_;\n      forceUpdate();\n    });\n    return unwatch;\n  }, [chainId, client, forceUpdate]);\n  return provider.current;\n}\n\nfunction useWebSocketProvider() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const forceUpdate = useForceUpdate();\n  const client = useClient();\n  const webSocketProvider = React.useRef(getWebSocketProvider({\n    chainId\n  }));\n  React.useEffect(() => {\n    const unwatch = watchWebSocketProvider({\n      chainId\n    }, webSocketProvider_ => {\n      webSocketProvider.current = webSocketProvider_;\n      forceUpdate();\n    });\n    return unwatch;\n  }, [chainId, client, forceUpdate]);\n  return webSocketProvider.current;\n}\n\nfunction useChainId() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const provider = useProvider({\n    chainId\n  });\n  return provider.network.chainId;\n}\n\nfunction useForceUpdate() {\n  const [, forceUpdate] = React.useReducer(x => x + 1, 0);\n  return forceUpdate;\n}\n\nfunction useQuery(queryKey, queryFn, options_) {\n  const options = {\n    queryKey,\n    queryFn,\n    ...options_\n  };\n  const queryClient = useQueryClient({\n    context: options.context\n  });\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false;\n    }\n  }\n\n  const [observer] = React.useState(() => new QueryObserver(queryClient, defaultedOptions));\n  const {\n    data,\n    dataUpdatedAt,\n    error,\n    errorUpdatedAt,\n    failureCount,\n    fetchStatus,\n    isError,\n    isFetched,\n    isFetchedAfterMount,\n    isFetching,\n    isLoading,\n    isLoadingError,\n    isPaused,\n    isPlaceholderData,\n    isPreviousData,\n    isRefetchError,\n    isRefetching,\n    isStale,\n    isSuccess,\n    refetch,\n    remove,\n    status: status_\n  } = observer.getOptimisticResult(defaultedOptions);\n  useSyncExternalStore(React.useCallback(onStoreChange => isRestoring ? () => undefined : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (defaultedOptions.suspense && isLoading && isFetching && !isRestoring) {\n    throw observer.fetchOptimistic(defaultedOptions).then(_ref => {\n      var _defaultedOptions$onS, _defaultedOptions$onS2;\n\n      let {\n        data\n      } = _ref;\n      (_defaultedOptions$onS = defaultedOptions.onSuccess) === null || _defaultedOptions$onS === void 0 ? void 0 : _defaultedOptions$onS.call(defaultedOptions, data);\n      (_defaultedOptions$onS2 = defaultedOptions.onSettled) === null || _defaultedOptions$onS2 === void 0 ? void 0 : _defaultedOptions$onS2.call(defaultedOptions, data, null);\n    }).catch(error => {\n      var _defaultedOptions$onE, _defaultedOptions$onS3;\n\n      errorResetBoundary.clearReset();\n      (_defaultedOptions$onE = defaultedOptions.onError) === null || _defaultedOptions$onE === void 0 ? void 0 : _defaultedOptions$onE.call(defaultedOptions, error);\n      (_defaultedOptions$onS3 = defaultedOptions.onSettled) === null || _defaultedOptions$onS3 === void 0 ? void 0 : _defaultedOptions$onS3.call(defaultedOptions, undefined, error);\n    });\n  } // Handle error boundary\n\n\n  if (isError && !errorResetBoundary.isReset() && !isFetching && shouldThrowError(defaultedOptions.useErrorBoundary, [error, observer.getCurrentQuery()])) {\n    throw error;\n  }\n\n  const status = status_ === 'loading' && fetchStatus === 'idle' ? 'idle' : status_;\n  const isIdle = status === 'idle';\n  const isLoading_ = status === 'loading' && fetchStatus === 'fetching';\n  const result = {\n    data,\n    error,\n    fetchStatus,\n    isError,\n    isFetched,\n    isFetching,\n    isIdle,\n    isLoading: isLoading_,\n    isRefetching,\n    isSuccess,\n    refetch,\n    status,\n    internal: {\n      dataUpdatedAt,\n      errorUpdatedAt,\n      failureCount,\n      isFetchedAfterMount,\n      isLoadingError,\n      isPaused,\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError,\n      isStale,\n      remove\n    }\n  }; // Handle result property usage tracking\n\n  return !defaultedOptions.notifyOnChangeProps ? trackResult(result, observer) : result;\n}\n\nfunction trackResult(result, observer) {\n  const trackedResult = {};\n  Object.keys(result).forEach(key => {\n    Object.defineProperty(trackedResult, key, {\n      configurable: false,\n      enumerable: true,\n      get: () => {\n        // @ts-expect-error – aware we are mutating private `trackedProps` property.\n        observer.trackedProps.add(key);\n        return result[key];\n      }\n    });\n  });\n  return trackedResult;\n}\n\nfunction shouldThrowError(_useErrorBoundary, params) {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params);\n  }\n\n  return !!_useErrorBoundary;\n}\n\nconst queryKey$b = () => [{\n  entity: 'account'\n}];\n\nconst queryFn$b = () => {\n  const result = getAccount();\n  if (result.address) return result;\n  return null;\n};\n\nfunction useAccount() {\n  let {\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const queryClient = useQueryClient();\n  const accountQuery = useQuery(queryKey$b(), queryFn$b, {\n    staleTime: 0,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n  React.useEffect(() => {\n    const unwatch = watchAccount(data => {\n      queryClient.setQueryData(queryKey$b(), data !== null && data !== void 0 && data.address ? data : null);\n    });\n    return unwatch;\n  }, [queryClient]);\n  return accountQuery;\n}\n\nconst queryKey$a = _ref => {\n  let {\n    chainId\n  } = _ref;\n  return [{\n    entity: 'blockNumber',\n    chainId\n  }];\n};\n\nconst queryFn$a = _ref2 => {\n  let {\n    queryKey: [{\n      chainId\n    }]\n  } = _ref2;\n  return fetchBlockNumber({\n    chainId\n  });\n};\n\nfunction useBlockNumber() {\n  let {\n    cacheTime = 0,\n    chainId: chainId_,\n    enabled = true,\n    staleTime,\n    suspense,\n    watch = false,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const provider = useProvider();\n  const webSocketProvider = useWebSocketProvider();\n  const queryClient = useQueryClient();\n  React.useEffect(() => {\n    if (!watch) return;\n\n    const listener = blockNumber => {\n      // Just to be safe in case the provider implementation\n      // calls the event callback after .off() has been called\n      queryClient.setQueryData(queryKey$a({\n        chainId\n      }), blockNumber);\n    };\n\n    const provider_ = webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider;\n    provider_.on('block', listener);\n    return () => {\n      provider_.off('block', listener);\n    };\n  }, [chainId, provider, queryClient, watch, webSocketProvider]);\n  return useQuery(queryKey$a({\n    chainId\n  }), queryFn$a, {\n    cacheTime,\n    enabled,\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst queryKey$9 = _ref => {\n  let {\n    chainId,\n    formatUnits\n  } = _ref;\n  return [{\n    entity: 'feeData',\n    chainId,\n    formatUnits\n  }];\n};\n\nconst queryFn$9 = _ref2 => {\n  let {\n    queryKey: [{\n      chainId,\n      formatUnits\n    }]\n  } = _ref2;\n  return fetchFeeData({\n    chainId,\n    formatUnits\n  });\n};\n\nfunction useFeeData() {\n  let {\n    cacheTime,\n    chainId: chainId_,\n    enabled = true,\n    formatUnits = 'wei',\n    staleTime,\n    suspense,\n    watch,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const feeDataQuery = useQuery(queryKey$9({\n    chainId,\n    formatUnits\n  }), queryFn$9, {\n    cacheTime,\n    enabled,\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n  const {\n    data: blockNumber\n  } = useBlockNumber({\n    watch\n  });\n  React.useEffect(() => {\n    if (!enabled) return;\n    if (!watch) return;\n    if (!blockNumber) return;\n    feeDataQuery.refetch(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [blockNumber]);\n  return feeDataQuery;\n}\n\nconst queryKey$8 = _ref => {\n  let {\n    addressOrName,\n    chainId,\n    formatUnits,\n    token\n  } = _ref;\n  return [{\n    entity: 'balance',\n    addressOrName,\n    chainId,\n    formatUnits,\n    token\n  }];\n};\n\nconst queryFn$8 = _ref2 => {\n  let {\n    queryKey: [{\n      addressOrName,\n      chainId,\n      formatUnits,\n      token\n    }]\n  } = _ref2;\n  if (!addressOrName) throw new Error('address is required');\n  return fetchBalance({\n    addressOrName,\n    chainId,\n    formatUnits,\n    token\n  });\n};\n\nfunction useBalance() {\n  let {\n    addressOrName,\n    cacheTime,\n    chainId: chainId_,\n    enabled = true,\n    formatUnits = 'ether',\n    staleTime,\n    suspense,\n    token,\n    watch,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const balanceQuery = useQuery(queryKey$8({\n    addressOrName,\n    chainId,\n    formatUnits,\n    token\n  }), queryFn$8, {\n    cacheTime,\n    enabled: Boolean(enabled && addressOrName),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n  const {\n    data: blockNumber\n  } = useBlockNumber({\n    watch\n  });\n  React.useEffect(() => {\n    if (!enabled) return;\n    if (!watch) return;\n    if (!blockNumber) return;\n    if (!addressOrName) return;\n    balanceQuery.refetch(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [blockNumber]);\n  return balanceQuery;\n}\n\nconst mutationKey$6 = args => [{\n  entity: 'connect',\n  ...args\n}];\n\nconst mutationFn$5 = args => {\n  const {\n    connector,\n    chainId\n  } = args;\n  if (!connector) throw new Error('connector is required');\n  return connect({\n    connector,\n    chainId\n  });\n};\n\nfunction useConnect() {\n  let {\n    chainId,\n    connector,\n    onBeforeConnect,\n    onConnect,\n    onError,\n    onSettled\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const forceUpdate = useForceUpdate();\n  const client = useClient();\n  const {\n    data,\n    error,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey$6({\n    connector,\n    chainId\n  }), mutationFn$5, {\n    onError,\n    onMutate: onBeforeConnect,\n    onSettled,\n    onSuccess: onConnect\n  });\n  React.useEffect(() => {\n    // Trigger update when connector or status change\n    const unsubscribe = client.subscribe(state => ({\n      connector: state.connector,\n      connectors: state.connectors,\n      status: state.status\n    }), forceUpdate, {\n      equalityFn: (selected, previous) => selected.connector === previous.connector && selected.connectors === previous.connectors && selected.status === previous.status\n    });\n    return unsubscribe;\n  }, [client, forceUpdate]);\n  const connect = React.useCallback(connectorOrArgs => {\n    let config;\n\n    if (connectorOrArgs instanceof Connector) {\n      const connector_ = connectorOrArgs;\n      config = {\n        chainId,\n        connector: connector_ !== null && connector_ !== void 0 ? connector_ : connector\n      };\n    } else {\n      var _args$chainId, _args$connector;\n\n      const args = connectorOrArgs;\n      config = {\n        chainId: (_args$chainId = args === null || args === void 0 ? void 0 : args.chainId) !== null && _args$chainId !== void 0 ? _args$chainId : chainId,\n        connector: (_args$connector = args === null || args === void 0 ? void 0 : args.connector) !== null && _args$connector !== void 0 ? _args$connector : connector\n      };\n    }\n\n    return mutate(config);\n  }, [chainId, connector, mutate]);\n  const connectAsync = React.useCallback(connectorOrArgs => {\n    let config;\n\n    if (connectorOrArgs instanceof Connector) {\n      const connector_ = connectorOrArgs;\n      config = {\n        chainId,\n        connector: connector_ !== null && connector_ !== void 0 ? connector_ : connector\n      };\n    } else {\n      var _args$chainId2, _args$connector2;\n\n      const args = connectorOrArgs;\n      config = {\n        chainId: (_args$chainId2 = args === null || args === void 0 ? void 0 : args.chainId) !== null && _args$chainId2 !== void 0 ? _args$chainId2 : chainId,\n        connector: (_args$connector2 = args === null || args === void 0 ? void 0 : args.connector) !== null && _args$connector2 !== void 0 ? _args$connector2 : connector\n      };\n    }\n\n    return mutateAsync(config);\n  }, [chainId, connector, mutateAsync]);\n  let status_;\n  if (client.status === 'reconnecting') status_ = 'reconnecting';else if (status === 'loading' || client.status === 'connecting') status_ = 'connecting';else if (client.connector) status_ = 'connected';else if (!client.connector || status === 'success') status_ = 'disconnected';else status_ = status;\n  return {\n    activeConnector: client.connector,\n    connect,\n    connectAsync,\n    connectors: client.connectors,\n    data,\n    error,\n    isConnected: status_ === 'connected',\n    isConnecting: status_ === 'connecting',\n    isDisconnected: status_ === 'disconnected',\n    isError: status === 'error',\n    isIdle: status_ === 'idle',\n    isReconnecting: status_ === 'reconnecting',\n    pendingConnector: variables === null || variables === void 0 ? void 0 : variables.connector,\n    reset,\n    status: status_\n  };\n}\n\nconst mutationKey$5 = [{\n  entity: 'disconnect'\n}];\n\nconst mutationFn$4 = () => disconnect();\n\nfunction useDisconnect() {\n  let {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const queryClient = useQueryClient();\n  const {\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate: disconnect,\n    mutateAsync: disconnectAsync,\n    reset,\n    status\n  } = useMutation(mutationKey$5, mutationFn$4, { ...(onError ? {\n      onError(error, _variables, context) {\n        onError(error, context);\n      }\n\n    } : {}),\n    onMutate,\n    ...(onSettled ? {\n      onSettled(_data, error, _variables, context) {\n        onSettled(error, context);\n      }\n\n    } : {}),\n\n    onSuccess(_data, _variables, context) {\n      // Clear account cache\n      queryClient.removeQueries(queryKey$b()); // Pass on arguments\n\n      onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(context);\n    }\n\n  });\n  return {\n    disconnect,\n    disconnectAsync,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    status\n  };\n}\n\nconst mutationKey$4 = args => [{\n  entity: 'switchNetwork',\n  ...args\n}];\n\nconst mutationFn$3 = args => {\n  const {\n    chainId\n  } = args;\n  if (!chainId) throw new Error('chainId is required');\n  return switchNetwork({\n    chainId\n  });\n};\n\nfunction useNetwork() {\n  var _network$current$chai;\n\n  let {\n    chainId,\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const forceUpdate = useForceUpdate();\n  const network = React.useRef(getNetwork());\n  const client = useClient();\n  const queryClient = useQueryClient();\n  const connector = client.connector;\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey$4({\n    chainId\n  }), mutationFn$3, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  React.useEffect(() => {\n    const unwatch = watchNetwork(data => {\n      network.current = data;\n      forceUpdate();\n    });\n    return unwatch;\n  }, [forceUpdate, queryClient]);\n  const switchNetwork_ = React.useCallback(chainId_ => mutate({\n    chainId: chainId_ !== null && chainId_ !== void 0 ? chainId_ : chainId\n  }), [chainId, mutate]);\n  const switchNetworkAsync_ = React.useCallback(chainId_ => mutateAsync({\n    chainId: chainId_ !== null && chainId_ !== void 0 ? chainId_ : chainId\n  }), [chainId, mutateAsync]);\n  return {\n    activeChain: network.current.chain,\n    chains: (_network$current$chai = network.current.chains) !== null && _network$current$chai !== void 0 ? _network$current$chai : [],\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    pendingChainId: variables === null || variables === void 0 ? void 0 : variables.chainId,\n    reset,\n    status,\n    switchNetwork: connector !== null && connector !== void 0 && connector.switchChain ? switchNetwork_ : undefined,\n    switchNetworkAsync: connector !== null && connector !== void 0 && connector.switchChain ? switchNetworkAsync_ : undefined,\n    variables\n  };\n}\n\nconst queryKey$7 = () => [{\n  entity: 'signer'\n}];\n\nconst queryFn$7 = () => fetchSigner();\n\nfunction useSigner() {\n  let {\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const signerQuery = useQuery(queryKey$7(), queryFn$7, {\n    cacheTime: 0,\n    staleTime: 0,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n  const queryClient = useQueryClient();\n  React.useEffect(() => {\n    const unwatch = watchSigner(signer => queryClient.setQueryData(queryKey$7(), signer));\n    return unwatch;\n  }, [queryClient]);\n  return signerQuery;\n}\n\nconst mutationKey$3 = args => [{\n  entity: 'signMessage',\n  ...args\n}];\n\nconst mutationFn$2 = args => {\n  const {\n    message\n  } = args;\n  if (!message) throw new Error('message is required');\n  return signMessage({\n    message\n  });\n};\n\nfunction useSignMessage() {\n  let {\n    message,\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey$3({\n    message\n  }), mutationFn$2, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  const signMessage = React.useCallback(args => mutate(args || {\n    message\n  }), [message, mutate]);\n  const signMessageAsync = React.useCallback(args => mutateAsync(args || {\n    message\n  }), [message, mutateAsync]);\n  return {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    signMessage,\n    signMessageAsync,\n    status,\n    variables\n  };\n}\n\nconst mutationKey$2 = args => [{\n  entity: 'signTypedData',\n  ...args\n}];\n\nconst mutationFn$1 = args => {\n  const {\n    domain,\n    types,\n    value\n  } = args;\n  if (!domain || !types || !value) throw new Error('domain, types, and value are all required');\n  return signTypedData({\n    domain,\n    types,\n    value\n  });\n};\n\nfunction useSignTypedData() {\n  let {\n    domain,\n    types,\n    value,\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey$2({\n    domain,\n    types,\n    value\n  }), mutationFn$1, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  const signTypedData = React.useCallback(args => mutate(args || {\n    domain,\n    types,\n    value\n  }), [domain, types, value, mutate]);\n  const signTypedDataAsync = React.useCallback(args => mutateAsync(args || {\n    domain,\n    types,\n    value\n  }), [domain, types, value, mutateAsync]);\n  return {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    signTypedData,\n    signTypedDataAsync,\n    status,\n    variables\n  };\n}\n\nconst useContract = _ref => {\n  let {\n    addressOrName,\n    contractInterface,\n    signerOrProvider\n  } = _ref;\n  return React.useMemo(() => {\n    return getContract({\n      addressOrName,\n      contractInterface,\n      signerOrProvider\n    });\n  }, [addressOrName, contractInterface, signerOrProvider]);\n};\n\nconst useContractEvent = function (contractConfig, eventName, listener) {\n  let {\n    chainId,\n    once\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const provider = useProvider({\n    chainId\n  });\n  const webSocketProvider = useWebSocketProvider({\n    chainId\n  });\n  const contract = useContract({\n    signerOrProvider: webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider,\n    ...contractConfig\n  });\n  const listenerRef = React.useRef(listener);\n  listenerRef.current = listener;\n  React.useEffect(() => {\n    const handler = function () {\n      for (var _len = arguments.length, event = new Array(_len), _key = 0; _key < _len; _key++) {\n        event[_key] = arguments[_key];\n      }\n\n      return listenerRef.current(event);\n    };\n\n    const contract_ = contract;\n    if (once) contract_.once(eventName, handler);else contract_.on(eventName, handler);\n    return () => {\n      contract_.off(eventName, handler);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [contract, eventName]);\n};\n\nconst queryKey$6 = _ref => {\n  let [contractConfig, functionName, {\n    args,\n    chainId,\n    overrides\n  }, {\n    blockNumber\n  }] = _ref;\n  return [{\n    entity: 'readContract',\n    args,\n    blockNumber,\n    chainId,\n    contractConfig,\n    functionName,\n    overrides\n  }];\n};\n\nconst queryFn$6 = _ref2 => {\n  let {\n    queryKey: [{\n      args,\n      chainId,\n      contractConfig,\n      functionName,\n      overrides\n    }]\n  } = _ref2;\n  return readContract(contractConfig, functionName, {\n    args,\n    chainId,\n    overrides\n  });\n};\n\nfunction useContractRead(contractConfig, functionName) {\n  let {\n    args,\n    chainId: chainId_,\n    overrides,\n    cacheOnBlock = false,\n    cacheTime,\n    enabled: enabled_ = true,\n    staleTime,\n    suspense,\n    watch,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  const {\n    data: blockNumber\n  } = useBlockNumber({\n    enabled: watch || cacheOnBlock,\n    watch\n  });\n  const queryKey_ = React.useMemo(() => queryKey$6([contractConfig, functionName, {\n    args,\n    chainId,\n    overrides\n  }, {\n    blockNumber: cacheOnBlock ? blockNumber : undefined\n  }]), [args, blockNumber, cacheOnBlock, chainId, contractConfig, functionName, overrides]);\n  const enabled = React.useMemo(() => {\n    let enabled = Boolean(enabled_ && contractConfig && functionName);\n    if (cacheOnBlock) enabled = Boolean(enabled && blockNumber);\n    return enabled;\n  }, [blockNumber, cacheOnBlock, contractConfig, enabled_, functionName]);\n  const client = useQueryClient();\n  React.useEffect(() => {\n    if (enabled) {\n      const unwatch = watchReadContract(contractConfig, functionName, {\n        args,\n        chainId,\n        overrides,\n        listenToBlock: watch && !cacheOnBlock\n      }, result => client.setQueryData(queryKey_, result));\n      return unwatch;\n    }\n  }, [args, cacheOnBlock, chainId, client, contractConfig, enabled, functionName, overrides, queryKey_, watch]);\n  return useQuery(queryKey_, queryFn$6, {\n    cacheTime,\n    enabled,\n    select: data => parseContractResult({\n      contractInterface: contractConfig.contractInterface,\n      data,\n      functionName\n    }),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst mutationKey$1 = _ref => {\n  let [contractConfig, functionName, {\n    args,\n    overrides\n  }] = _ref;\n  return [{\n    entity: 'writeContract',\n    args,\n    contractConfig,\n    functionName,\n    overrides\n  }];\n};\nfunction useContractWrite(contractConfig, functionName) {\n  let {\n    args,\n    overrides,\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey$1([contractConfig, functionName, {\n    args,\n    overrides\n  }]), _ref2 => {\n    let {\n      args,\n      overrides\n    } = _ref2;\n    return writeContract(contractConfig, functionName, {\n      args,\n      overrides\n    });\n  }, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  const write = React.useCallback(overrideConfig => mutate(overrideConfig || {\n    args,\n    overrides\n  }), [args, mutate, overrides]);\n  const writeAsync = React.useCallback(overrideConfig => mutateAsync(overrideConfig || {\n    args,\n    overrides\n  }), [args, mutateAsync, overrides]);\n  return {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    status,\n    variables,\n    write,\n    writeAsync\n  };\n}\n\nconst queryKey$5 = _ref => {\n  let {\n    address,\n    chainId,\n    formatUnits\n  } = _ref;\n  return [{\n    entity: 'token',\n    address,\n    chainId,\n    formatUnits\n  }];\n};\n\nconst queryFn$5 = _ref2 => {\n  let {\n    queryKey: [{\n      address,\n      chainId,\n      formatUnits\n    }]\n  } = _ref2;\n  if (!address) throw new Error('address is required');\n  return fetchToken({\n    address,\n    chainId,\n    formatUnits\n  });\n};\n\nfunction useToken() {\n  let {\n    address,\n    chainId: chainId_,\n    formatUnits = 'ether',\n    cacheTime,\n    enabled = true,\n    staleTime = 1000 * 60 * 60 * 24,\n    // 24 hours\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$5({\n    address,\n    chainId,\n    formatUnits\n  }), queryFn$5, {\n    cacheTime,\n    enabled: Boolean(enabled && address),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst queryKey$4 = _ref => {\n  let {\n    chainId,\n    name\n  } = _ref;\n  return [{\n    entity: 'ensAddress',\n    chainId,\n    name\n  }];\n};\n\nconst queryFn$4 = _ref2 => {\n  let {\n    queryKey: [{\n      chainId,\n      name\n    }]\n  } = _ref2;\n  if (!name) throw new Error('name is required');\n  return fetchEnsAddress({\n    chainId,\n    name\n  });\n};\n\nfunction useEnsAddress() {\n  let {\n    cacheTime,\n    chainId: chainId_,\n    enabled = true,\n    name,\n    staleTime = 1000 * 60 * 60 * 24,\n    // 24 hours\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$4({\n    chainId,\n    name\n  }), queryFn$4, {\n    cacheTime,\n    enabled: Boolean(enabled && chainId && name),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst queryKey$3 = _ref => {\n  let {\n    addressOrName,\n    chainId\n  } = _ref;\n  return [{\n    entity: 'ensAvatar',\n    addressOrName,\n    chainId\n  }];\n};\n\nconst queryFn$3 = _ref2 => {\n  let {\n    queryKey: [{\n      addressOrName,\n      chainId\n    }]\n  } = _ref2;\n  if (!addressOrName) throw new Error('addressOrName is required');\n  return fetchEnsAvatar({\n    addressOrName,\n    chainId\n  });\n};\n\nfunction useEnsAvatar() {\n  let {\n    addressOrName,\n    cacheTime,\n    chainId: chainId_,\n    enabled = true,\n    staleTime = 1000 * 60 * 60 * 24,\n    // 24 hours\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$3({\n    addressOrName,\n    chainId\n  }), queryFn$3, {\n    cacheTime,\n    enabled: Boolean(enabled && addressOrName && chainId),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst queryKey$2 = _ref => {\n  let {\n    address,\n    chainId\n  } = _ref;\n  return [{\n    entity: 'ensName',\n    address,\n    chainId\n  }];\n};\n\nconst queryFn$2 = _ref2 => {\n  let {\n    queryKey: [{\n      address,\n      chainId\n    }]\n  } = _ref2;\n  if (!address) throw new Error('address is required');\n  return fetchEnsName({\n    address,\n    chainId\n  });\n};\n\nfunction useEnsName() {\n  let {\n    address,\n    cacheTime,\n    chainId: chainId_,\n    enabled = true,\n    staleTime = 1000 * 60 * 60 * 24,\n    // 24 hours\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$2({\n    address,\n    chainId\n  }), queryFn$2, {\n    cacheTime,\n    enabled: Boolean(enabled && address && chainId),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst queryKey$1 = _ref => {\n  let {\n    chainId,\n    name\n  } = _ref;\n  return [{\n    entity: 'ensResolver',\n    chainId,\n    name\n  }];\n};\n\nconst queryFn$1 = _ref2 => {\n  let {\n    queryKey: [{\n      chainId,\n      name\n    }]\n  } = _ref2;\n  if (!name) throw new Error('name is required');\n  return fetchEnsResolver({\n    chainId,\n    name\n  });\n};\n\nfunction useEnsResolver() {\n  let {\n    cacheTime,\n    chainId: chainId_,\n    enabled = true,\n    name,\n    staleTime = 1000 * 60 * 60 * 24,\n    // 24 hours\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$1({\n    chainId,\n    name\n  }), queryFn$1, {\n    cacheTime,\n    enabled: Boolean(enabled && chainId && name),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nconst mutationKey = args => [{\n  entity: 'sendTransaction',\n  ...args\n}];\n\nconst mutationFn = args => {\n  const {\n    request\n  } = args;\n  if (!request) throw new Error('request is required');\n  return sendTransaction({\n    request\n  });\n};\n\nfunction useSendTransaction() {\n  let {\n    request,\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    mutate,\n    mutateAsync,\n    reset,\n    status,\n    variables\n  } = useMutation(mutationKey({\n    request\n  }), mutationFn, {\n    onError,\n    onMutate,\n    onSettled,\n    onSuccess\n  });\n  const sendTransaction = React.useCallback(args => mutate(args || {\n    request\n  }), [mutate, request]);\n  const sendTransactionAsync = React.useCallback(args => mutateAsync(args || {\n    request\n  }), [mutateAsync, request]);\n  return {\n    data,\n    error,\n    isError,\n    isIdle,\n    isLoading,\n    isSuccess,\n    reset,\n    sendTransaction,\n    sendTransactionAsync,\n    status,\n    variables\n  };\n}\n\nconst queryKey = _ref => {\n  let {\n    confirmations,\n    chainId,\n    hash,\n    timeout,\n    wait\n  } = _ref;\n  return [{\n    entity: 'waitForTransaction',\n    confirmations,\n    chainId,\n    hash,\n    timeout,\n    wait\n  }];\n};\n\nconst queryFn = _ref2 => {\n  let {\n    queryKey: [{\n      chainId,\n      confirmations,\n      hash,\n      timeout,\n      wait\n    }]\n  } = _ref2;\n  return waitForTransaction({\n    chainId,\n    confirmations,\n    hash,\n    timeout,\n    wait\n  });\n};\n\nfunction useWaitForTransaction() {\n  let {\n    chainId: chainId_,\n    confirmations,\n    hash,\n    timeout,\n    wait,\n    cacheTime,\n    enabled = true,\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey({\n    chainId,\n    confirmations,\n    hash,\n    timeout,\n    wait\n  }), queryFn, {\n    cacheTime,\n    enabled: Boolean(enabled && (hash || wait)),\n    staleTime,\n    suspense,\n    onError,\n    onSettled,\n    onSuccess\n  });\n}\n\nexport { Context, WagmiConfig, WagmiConfig as WagmiProvider, createClient, deserialize, serialize, useAccount, useBalance, useBlockNumber, useClient, useConnect, useContract, useContractEvent, useContractRead, useContractWrite, useDisconnect, useEnsAddress, useEnsAvatar, useEnsName, useEnsResolver, useFeeData, useNetwork, useProvider, useQuery, useSendTransaction, useSignMessage, useSignTypedData, useSigner, useToken, useWaitForTransaction, useWebSocketProvider };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}