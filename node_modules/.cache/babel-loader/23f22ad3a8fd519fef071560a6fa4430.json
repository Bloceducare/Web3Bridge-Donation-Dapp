{"ast":null,"code":"import { focusManager } from \"./focusManager.mjs\";\nimport { onlineManager } from \"./onlineManager.mjs\";\nimport { sleep } from \"./utils.mjs\";\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nexport function canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nexport class CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nexport function isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nexport function createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay; // Stop if the fetch is already resolved\n\n\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}","map":{"version":3,"names":["focusManager","onlineManager","sleep","defaultRetryDelay","failureCount","Math","min","canFetch","networkMode","isOnline","CancelledError","constructor","options","revert","silent","isCancelledError","value","createRetryer","config","isRetryCancelled","isResolved","continueFn","promiseResolve","promiseReject","promise","Promise","outerResolve","outerReject","cancel","cancelOptions","reject","abort","cancelRetry","continueRetry","shouldPause","isFocused","resolve","onSuccess","onError","pause","continueResolve","onPause","then","undefined","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","continue"],"sources":["/home/king-longs/Desktop/final/node_modules/react-query/lib/core/retryer.mjs"],"sourcesContent":["import { focusManager } from \"./focusManager.mjs\";\nimport { onlineManager } from \"./onlineManager.mjs\";\nimport { sleep } from \"./utils.mjs\";\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nexport function canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nexport class CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nexport function isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nexport function createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}