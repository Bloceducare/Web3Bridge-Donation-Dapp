{"ast":null,"code":"import { difference, replaceAt } from \"./utils.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { QueryObserver } from \"./queryObserver.mjs\";\nimport { Subscribable } from \"./subscribable.mjs\";\nexport class QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObservers.find(observer => observer.options.queryHash === defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = matchingObservers.map(match => match.defaultedQueryOptions.queryHash);\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.includes(defaultedOptions.queryHash));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObservers.some(match => match.observer === prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result);\n      });\n    });\n  }\n\n}","map":{"version":3,"names":["difference","replaceAt","notifyManager","QueryObserver","Subscribable","QueriesObserver","constructor","client","queries","result","observers","observersMap","setQueries","onSubscribe","listeners","length","forEach","observer","subscribe","onUpdate","onUnsubscribe","destroy","notifyOptions","batch","prevObservers","newObserverMatches","findMatchingObservers","match","setOptions","defaultedQueryOptions","newObservers","map","newObserversMap","Object","fromEntries","options","queryHash","newResult","getCurrentResult","hasIndexChange","some","index","hasListeners","notify","getOptimisticResult","defaultQueryOptions","matchingObservers","flatMap","defaultedOptions","find","matchedQueryHashes","unmatchedQueries","filter","includes","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","keepPreviousData","previouslyUsedObserver","undefined","sortMatchesByOrderOfQueries","a","b","indexOf","concat","sort","listener"],"sources":["/home/king-longs/Desktop/final/node_modules/react-query/lib/core/queriesObserver.mjs"],"sourcesContent":["import { difference, replaceAt } from \"./utils.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { QueryObserver } from \"./queryObserver.mjs\";\nimport { Subscribable } from \"./subscribable.mjs\";\nexport class QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObservers.find(observer => observer.options.queryHash === defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = matchingObservers.map(match => match.defaultedQueryOptions.queryHash);\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.includes(defaultedOptions.queryHash));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObservers.some(match => match.observer === prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result);\n      });\n    });\n  }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}