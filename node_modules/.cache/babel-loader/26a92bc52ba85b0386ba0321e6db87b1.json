{"ast":null,"code":"import { hashQueryKey, noop, parseFilterArgs, parseQueryArgs, partialMatchKey, hashQueryKeyByOptions, functionalUpdate } from \"./utils.mjs\";\nimport { QueryCache } from \"./queryCache.mjs\";\nimport { MutationCache } from \"./mutationCache.mjs\";\nimport { focusManager } from \"./focusManager.mjs\";\nimport { onlineManager } from \"./onlineManager.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.mjs\";\nimport { defaultLogger } from \"./logger.mjs\"; // TYPES\n// CLASS\n\nexport class QueryClient {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n\n  mount() {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(_ref2 => {\n      let {\n        queryKey,\n        state\n      } = _ref2;\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(_ref3 => {\n      let {\n        queryKey\n      } = _ref3;\n      return [queryKey, this.setQueryData(queryKey, updater, options)];\n    }));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}","map":{"version":3,"names":["hashQueryKey","noop","parseFilterArgs","parseQueryArgs","partialMatchKey","hashQueryKeyByOptions","functionalUpdate","QueryCache","MutationCache","focusManager","onlineManager","notifyManager","infiniteQueryBehavior","defaultLogger","QueryClient","constructor","config","queryCache","mutationCache","logger","defaultOptions","queryDefaults","mutationDefaults","mount","unsubscribeFocus","subscribe","isFocused","resumePausedMutations","onFocus","unsubscribeOnline","isOnline","onOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","call","isFetching","arg1","arg2","filters","fetchStatus","findAll","length","isMutating","fetching","getQueryData","queryKey","_this$queryCache$find","find","state","data","getQueriesData","queryKeyOrFilters","getQueryCache","map","setQueryData","updater","options","query","prevData","undefined","parsedOptions","defaultedOptions","defaultQueryOptions","build","setData","manual","setQueriesData","batch","getQueryState","_this$queryCache$find2","removeQueries","forEach","remove","resetQueries","arg3","refetchFilters","type","reset","refetchQueries","cancelQueries","cancelOptions","revert","promises","cancel","Promise","all","then","catch","invalidateQueries","_ref","_filters$refetchType","invalidate","refetchType","resolve","filter","isDisabled","_options$cancelRefetc","fetch","cancelRefetch","meta","refetchPage","promise","throwOnError","fetchQuery","retry","isStaleByTime","staleTime","prefetchQuery","fetchInfiniteQuery","behavior","prefetchInfiniteQuery","getMutationCache","getLogger","getDefaultOptions","setDefaultOptions","setQueryDefaults","result","x","push","getQueryDefaults","firstMatchingDefaults","process","env","NODE_ENV","matchingDefaults","error","JSON","stringify","setMutationDefaults","mutationKey","getMutationDefaults","_defaulted","queries","queryHash","refetchOnReconnect","networkMode","useErrorBoundary","suspense","defaultMutationOptions","mutations","clear"],"sources":["/home/king-longs/Desktop/final/node_modules/react-query/lib/core/queryClient.mjs"],"sourcesContent":["import { hashQueryKey, noop, parseFilterArgs, parseQueryArgs, partialMatchKey, hashQueryKeyByOptions, functionalUpdate } from \"./utils.mjs\";\nimport { QueryCache } from \"./queryCache.mjs\";\nimport { MutationCache } from \"./mutationCache.mjs\";\nimport { focusManager } from \"./focusManager.mjs\";\nimport { onlineManager } from \"./onlineManager.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.mjs\";\nimport { defaultLogger } from \"./logger.mjs\"; // TYPES\n\n// CLASS\nexport class QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n\n  mount() {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}