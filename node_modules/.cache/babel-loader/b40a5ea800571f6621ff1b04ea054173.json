{"ast":null,"code":"import { b as Connector, _ as _classPrivateMethodInitSpec, f as _defineProperty, g as _classPrivateFieldInitSpec, n as normalizeChainId, h as _classPrivateFieldGet, i as _classPrivateFieldSet, a as ConnectorNotFoundError, j as _classPrivateMethodGet, U as UserRejectedRequestError, R as ResourceUnavailableError, c as ChainNotConfiguredError, A as AddChainError, e as SwitchChainError } from './base-4c248b82.esm.js';\nimport { providers, getDefaultProvider } from 'ethers';\nimport create from 'zustand/vanilla';\nimport { subscribeWithSelector, persist } from 'zustand/middleware';\nimport { getAddress, hexValue } from 'ethers/lib/utils';\nimport { a as allChains } from './chains-42648bc5.esm.js';\n\nfunction getInjectedName(ethereum) {\n  var _ethereum$providers, _getName;\n\n  if (!ethereum) return 'Injected';\n\n  const getName = provider => {\n    if (provider.isBraveWallet) return 'Brave Wallet';\n    if (provider.isCoinbaseWallet) return 'Coinbase Wallet';\n    if (provider.isFrame) return 'Frame';\n    if (provider.isOpera) return 'Opera';\n    if (provider.isTally) return 'Tally';\n    if (provider.isTokenary) return 'Tokenary';\n    if (provider.isTrust) return 'Trust Wallet';\n    if (provider.isMetaMask) return 'MetaMask';\n  }; // Some injected providers detect multiple other providers and create a list at `ethers.providers`\n\n\n  if ((_ethereum$providers = ethereum.providers) !== null && _ethereum$providers !== void 0 && _ethereum$providers.length) {\n    var _names$; // Deduplicate names using Set\n    // Coinbase Wallet puts multiple providers in `ethereum.providers`\n\n\n    const nameSet = new Set();\n    let unknownCount = 1;\n\n    for (const provider of ethereum.providers) {\n      let name = getName(provider);\n\n      if (!name) {\n        name = \"Unknown Wallet #\".concat(unknownCount);\n        unknownCount += 1;\n      }\n\n      nameSet.add(name);\n    }\n\n    const names = [...nameSet];\n    if (names.length) return names;\n    return (_names$ = names[0]) !== null && _names$ !== void 0 ? _names$ : 'Injected';\n  }\n\n  return (_getName = getName(ethereum)) !== null && _getName !== void 0 ? _getName : 'Injected';\n}\n\nconst cache = new Set();\n\nfunction warn(message, id) {\n  if (!cache.has(id !== null && id !== void 0 ? id : message)) {\n    console.warn(message);\n    cache.add(message);\n  }\n}\n\nconst shimKey = 'injected.shimDisconnect';\n\nvar _provider = /*#__PURE__*/new WeakMap();\n\nvar _switchingChains = /*#__PURE__*/new WeakMap();\n\nvar _isUserRejectedRequestError = /*#__PURE__*/new WeakSet();\n\nclass InjectedConnector extends Connector {\n  constructor() {\n    let {\n      chains,\n      options = {\n        shimDisconnect: true\n      }\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      chains,\n      options\n    });\n\n    _classPrivateMethodInitSpec(this, _isUserRejectedRequestError);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"ready\", typeof window != 'undefined' && !!window.ethereum);\n\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _switchingChains, {\n      writable: true,\n      value: void 0\n    });\n\n    _defineProperty(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) this.emit('disconnect');else this.emit('change', {\n        account: getAddress(accounts[0])\n      });\n    });\n\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit('change', {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n\n    _defineProperty(this, \"onDisconnect\", () => {\n      var _this$options, _this$options2, _getClient$storage; // We need this as MetaMask can emit the \"disconnect\" event\n      // upon switching chains. This workaround ensures that the\n      // user currently isn't in the process of switching chains.\n\n\n      if ((_this$options = this.options) !== null && _this$options !== void 0 && _this$options.shimChainChangedDisconnect && _classPrivateFieldGet(this, _switchingChains)) {\n        _classPrivateFieldSet(this, _switchingChains, false);\n\n        return;\n      }\n\n      this.emit('disconnect');\n      if ((_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.shimDisconnect) (_getClient$storage = getClient().storage) === null || _getClient$storage === void 0 ? void 0 : _getClient$storage.removeItem(shimKey);\n    });\n\n    let name = 'Injected';\n\n    if (typeof window !== 'undefined') {\n      const overrideName = options.name;\n      const detectedName = getInjectedName(window.ethereum);\n      if (overrideName) name = typeof overrideName === 'function' ? overrideName(detectedName) : overrideName;else name = typeof detectedName === 'string' ? detectedName : detectedName[0];\n    }\n\n    this.id = 'injected';\n    this.name = name;\n  }\n\n  async connect() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      var _this$options3, _getClient$storage2;\n\n      const provider = await this.getProvider();\n      if (!provider) throw new ConnectorNotFoundError();\n\n      if (provider.on) {\n        provider.on('accountsChanged', this.onAccountsChanged);\n        provider.on('chainChanged', this.onChainChanged);\n        provider.on('disconnect', this.onDisconnect);\n      }\n\n      this.emit('message', {\n        type: 'connecting'\n      });\n      const account = await this.getAccount(); // Switch to chain if provided\n\n      let id = await this.getChainId();\n      let unsupported = this.isChainUnsupported(id);\n\n      if (chainId && id !== chainId) {\n        const chain = await this.switchChain(chainId);\n        id = chain.id;\n        unsupported = this.isChainUnsupported(id);\n      }\n\n      if ((_this$options3 = this.options) !== null && _this$options3 !== void 0 && _this$options3.shimDisconnect) (_getClient$storage2 = getClient().storage) === null || _getClient$storage2 === void 0 ? void 0 : _getClient$storage2.setItem(shimKey, true);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider\n      };\n    } catch (error) {\n      if (_classPrivateMethodGet(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, error)) throw new UserRejectedRequestError(error);\n      if (error.code === -32002) throw new ResourceUnavailableError(error);\n      throw error;\n    }\n  }\n\n  async disconnect() {\n    var _this$options4, _getClient$storage3;\n\n    const provider = await this.getProvider();\n    if (!(provider !== null && provider !== void 0 && provider.removeListener)) return;\n    provider.removeListener('accountsChanged', this.onAccountsChanged);\n    provider.removeListener('chainChanged', this.onChainChanged);\n    provider.removeListener('disconnect', this.onDisconnect);\n    if ((_this$options4 = this.options) !== null && _this$options4 !== void 0 && _this$options4.shimDisconnect) (_getClient$storage3 = getClient().storage) === null || _getClient$storage3 === void 0 ? void 0 : _getClient$storage3.removeItem(shimKey);\n  }\n\n  async getAccount() {\n    const provider = await this.getProvider();\n    if (!provider) throw new ConnectorNotFoundError();\n    const accounts = await provider.request({\n      method: 'eth_requestAccounts'\n    }); // return checksum address\n\n    return getAddress(accounts[0]);\n  }\n\n  async getChainId() {\n    const provider = await this.getProvider();\n    if (!provider) throw new ConnectorNotFoundError();\n    return await provider.request({\n      method: 'eth_chainId'\n    }).then(normalizeChainId);\n  }\n\n  async getProvider() {\n    if (typeof window !== 'undefined' && !!window.ethereum) _classPrivateFieldSet(this, _provider, window.ethereum);\n    return _classPrivateFieldGet(this, _provider);\n  }\n\n  async getSigner() {\n    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);\n    return new providers.Web3Provider(provider).getSigner(account);\n  }\n\n  async isAuthorized() {\n    try {\n      var _this$options5, _getClient$storage4;\n\n      if ((_this$options5 = this.options) !== null && _this$options5 !== void 0 && _this$options5.shimDisconnect && !((_getClient$storage4 = getClient().storage) !== null && _getClient$storage4 !== void 0 && _getClient$storage4.getItem(shimKey))) return false;\n      const provider = await this.getProvider();\n      if (!provider) throw new ConnectorNotFoundError();\n      const accounts = await provider.request({\n        method: 'eth_accounts'\n      });\n      const account = accounts[0];\n      return !!account;\n    } catch {\n      return false;\n    }\n  }\n\n  async switchChain(chainId) {\n    var _this$options6;\n\n    if ((_this$options6 = this.options) !== null && _this$options6 !== void 0 && _this$options6.shimChainChangedDisconnect) _classPrivateFieldSet(this, _switchingChains, true);\n    const provider = await this.getProvider();\n    if (!provider) throw new ConnectorNotFoundError();\n    const id = hexValue(chainId);\n\n    try {\n      var _chains$find;\n\n      await provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{\n          chainId: id\n        }]\n      });\n      const chains = [...this.chains, ...allChains];\n      return (_chains$find = chains.find(x => x.id === chainId)) !== null && _chains$find !== void 0 ? _chains$find : {\n        id: chainId,\n        name: \"Chain \".concat(id),\n        network: \"\".concat(id),\n        rpcUrls: {\n          default: ''\n        }\n      };\n    } catch (error) {\n      const chain = this.chains.find(x => x.id === chainId);\n      if (!chain) throw new ChainNotConfiguredError(); // Indicates chain is not added to provider\n\n      if (error.code === 4902) {\n        try {\n          await provider.request({\n            method: 'wallet_addEthereumChain',\n            params: [{\n              chainId: id,\n              chainName: chain.name,\n              nativeCurrency: chain.nativeCurrency,\n              rpcUrls: [chain.rpcUrls.default],\n              blockExplorerUrls: this.getBlockExplorerUrls(chain)\n            }]\n          });\n          return chain;\n        } catch (addError) {\n          if (_classPrivateMethodGet(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, addError)) throw new UserRejectedRequestError(error);\n          throw new AddChainError();\n        }\n      }\n\n      if (_classPrivateMethodGet(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, error)) throw new UserRejectedRequestError(error);\n      throw new SwitchChainError(error);\n    }\n  }\n\n  async watchAsset(_ref) {\n    let {\n      address,\n      decimals = 18,\n      image,\n      symbol\n    } = _ref;\n    const provider = await this.getProvider();\n    if (!provider) throw new ConnectorNotFoundError();\n    return await provider.request({\n      method: 'wallet_watchAsset',\n      params: {\n        type: 'ERC20',\n        options: {\n          address,\n          decimals,\n          image,\n          symbol\n        }\n      }\n    });\n  }\n\n}\n\nfunction _isUserRejectedRequestError2(error) {\n  return error.code === 4001;\n}\n\nconst noopStorage = {\n  getItem: _key => '',\n  setItem: (_key, _value) => null,\n  removeItem: _key => null\n};\n\nfunction createStorage(_ref) {\n  let {\n    storage,\n    key: prefix = 'wagmi'\n  } = _ref;\n  return { ...storage,\n    getItem: function (key) {\n      let defaultState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      const value = storage.getItem(\"\".concat(prefix, \".\").concat(key));\n\n      try {\n        return value ? JSON.parse(value) : defaultState;\n      } catch (error) {\n        console.warn(error);\n        return defaultState;\n      }\n    },\n    setItem: (key, value) => {\n      if (value === null) {\n        storage.removeItem(\"\".concat(prefix, \".\").concat(key));\n      } else {\n        try {\n          storage.setItem(\"\".concat(prefix, \".\").concat(key), JSON.stringify(value));\n        } catch (err) {\n          console.error(err);\n        }\n      }\n    },\n    removeItem: key => storage.removeItem(\"\".concat(prefix, \".\").concat(key))\n  };\n}\n\nconst storeKey = 'store';\n\nvar _isAutoConnecting = /*#__PURE__*/new WeakMap();\n\nvar _lastUsedConnector = /*#__PURE__*/new WeakMap();\n\nvar _addEffects = /*#__PURE__*/new WeakSet();\n\nclass Client {\n  constructor() {\n    let {\n      autoConnect = false,\n      connectors = [new InjectedConnector()],\n      provider: _provider = config => {\n        try {\n          return getDefaultProvider(config.chainId);\n        } catch {\n          return getDefaultProvider();\n        }\n      },\n      storage = createStorage({\n        storage: typeof window !== 'undefined' ? window.localStorage : noopStorage\n      }),\n      webSocketProvider: _webSocketProvider\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classPrivateMethodInitSpec(this, _addEffects);\n\n    _defineProperty(this, \"config\", void 0);\n\n    _defineProperty(this, \"storage\", void 0);\n\n    _defineProperty(this, \"store\", void 0);\n\n    _classPrivateFieldInitSpec(this, _isAutoConnecting, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _lastUsedConnector, {\n      writable: true,\n      value: void 0\n    }); // Check status for autoConnect flag\n\n\n    let status = 'disconnected';\n\n    let _chainId;\n\n    if (autoConnect) {\n      try {\n        var _JSON$parse, _JSON$parse$state, _data$chain;\n\n        const rawState = storage.getItem(storeKey, '');\n        const data = (_JSON$parse = JSON.parse(rawState || '{}')) === null || _JSON$parse === void 0 ? void 0 : (_JSON$parse$state = _JSON$parse.state) === null || _JSON$parse$state === void 0 ? void 0 : _JSON$parse$state.data; // If account exists in localStorage, set status to reconnecting\n\n        status = data !== null && data !== void 0 && data.account ? 'reconnecting' : 'connecting';\n        _chainId = data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id; // eslint-disable-next-line no-empty\n      } catch (_error) {}\n    } // Evaluate initial store values\n\n\n    const connectors_ = typeof connectors === 'function' ? connectors({\n      chainId: _chainId\n    }) : connectors;\n    const provider_ = typeof _provider === 'function' ? _provider({\n      chainId: _chainId\n    }) : _provider;\n    const webSocketProvider_ = typeof _webSocketProvider === 'function' ? _webSocketProvider({\n      chainId: _chainId\n    }) : _webSocketProvider; // Create store\n\n    this.store = create(subscribeWithSelector(persist(() => ({\n      connectors: connectors_,\n      provider: provider_,\n      status,\n      webSocketProvider: webSocketProvider_\n    }), {\n      name: storeKey,\n      getStorage: () => storage,\n      partialize: state => {\n        var _state$data, _state$data2;\n\n        return { ...(autoConnect && {\n            data: {\n              account: state === null || state === void 0 ? void 0 : (_state$data = state.data) === null || _state$data === void 0 ? void 0 : _state$data.account,\n              chain: state === null || state === void 0 ? void 0 : (_state$data2 = state.data) === null || _state$data2 === void 0 ? void 0 : _state$data2.chain\n            }\n          }),\n          chains: state === null || state === void 0 ? void 0 : state.chains\n        };\n      },\n      version: 1\n    })));\n    this.config = {\n      autoConnect,\n      connectors,\n      provider: _provider,\n      storage,\n      webSocketProvider: _webSocketProvider\n    };\n    this.storage = storage;\n\n    _classPrivateFieldSet(this, _lastUsedConnector, storage === null || storage === void 0 ? void 0 : storage.getItem('wallet'));\n\n    _classPrivateMethodGet(this, _addEffects, _addEffects2).call(this);\n  }\n\n  get chains() {\n    return this.store.getState().chains;\n  }\n\n  get connectors() {\n    return this.store.getState().connectors;\n  }\n\n  get connector() {\n    return this.store.getState().connector;\n  }\n\n  get data() {\n    return this.store.getState().data;\n  }\n\n  get error() {\n    return this.store.getState().error;\n  }\n\n  get lastUsedChainId() {\n    var _this$data, _this$data$chain;\n\n    return (_this$data = this.data) === null || _this$data === void 0 ? void 0 : (_this$data$chain = _this$data.chain) === null || _this$data$chain === void 0 ? void 0 : _this$data$chain.id;\n  }\n\n  get provider() {\n    return this.store.getState().provider;\n  }\n\n  get status() {\n    return this.store.getState().status;\n  }\n\n  get subscribe() {\n    return this.store.subscribe;\n  }\n\n  get webSocketProvider() {\n    return this.store.getState().webSocketProvider;\n  }\n\n  setState(updater) {\n    const newState = typeof updater === 'function' ? updater(this.store.getState()) : updater;\n    this.store.setState(newState, true);\n  }\n\n  clearState() {\n    this.setState(x => ({ ...x,\n      chains: undefined,\n      connector: undefined,\n      data: undefined,\n      error: undefined,\n      status: 'disconnected'\n    }));\n  }\n\n  async destroy() {\n    var _this$connector$disco, _this$connector;\n\n    if (this.connector) await ((_this$connector$disco = (_this$connector = this.connector).disconnect) === null || _this$connector$disco === void 0 ? void 0 : _this$connector$disco.call(_this$connector));\n\n    _classPrivateFieldSet(this, _isAutoConnecting, false);\n\n    this.clearState();\n    this.store.destroy();\n  }\n\n  async autoConnect() {\n    if (_classPrivateFieldGet(this, _isAutoConnecting)) return;\n\n    _classPrivateFieldSet(this, _isAutoConnecting, true);\n\n    if (!this.connectors.length) return; // Try last used connector first\n\n    const sorted = _classPrivateFieldGet(this, _lastUsedConnector) ? [...this.connectors].sort(x => x.id === _classPrivateFieldGet(this, _lastUsedConnector) ? -1 : 1) : this.connectors;\n    let connected = false;\n\n    for (const connector of sorted) {\n      if (!connector.ready || !connector.isAuthorized) continue;\n      const isAuthorized = await connector.isAuthorized();\n      if (!isAuthorized) continue;\n      const data = await connector.connect();\n      this.setState(x => ({ ...x,\n        connector,\n        chains: connector === null || connector === void 0 ? void 0 : connector.chains,\n        data,\n        status: 'connected'\n      }));\n      connected = true;\n      break;\n    } // If connecting didn't succeed, set to disconnected\n\n\n    if (!connected) this.setState(x => ({ ...x,\n      data: undefined,\n      status: 'disconnected'\n    }));\n\n    _classPrivateFieldSet(this, _isAutoConnecting, false);\n\n    return this.data;\n  }\n\n  setLastUsedConnector() {\n    var _this$storage;\n\n    let lastUsedConnector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    (_this$storage = this.storage) === null || _this$storage === void 0 ? void 0 : _this$storage.setItem('wallet', lastUsedConnector);\n  }\n\n}\n\nfunction _addEffects2() {\n  const onChange = data => {\n    this.setState(x => ({ ...x,\n      data: { ...x.data,\n        ...data\n      }\n    }));\n  };\n\n  const onDisconnect = () => {\n    this.clearState();\n  };\n\n  const onError = error => {\n    this.setState(x => ({ ...x,\n      error\n    }));\n  };\n\n  this.store.subscribe(_ref => {\n    let {\n      connector\n    } = _ref;\n    return connector;\n  }, (connector, prevConnector) => {\n    var _prevConnector$off, _prevConnector$off2, _prevConnector$off3, _connector$on, _connector$on2, _connector$on3;\n\n    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off = prevConnector.off) === null || _prevConnector$off === void 0 ? void 0 : _prevConnector$off.call(prevConnector, 'change', onChange);\n    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off2 = prevConnector.off) === null || _prevConnector$off2 === void 0 ? void 0 : _prevConnector$off2.call(prevConnector, 'disconnect', onDisconnect);\n    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off3 = prevConnector.off) === null || _prevConnector$off3 === void 0 ? void 0 : _prevConnector$off3.call(prevConnector, 'error', onError);\n    if (!connector) return;\n    (_connector$on = connector.on) === null || _connector$on === void 0 ? void 0 : _connector$on.call(connector, 'change', onChange);\n    (_connector$on2 = connector.on) === null || _connector$on2 === void 0 ? void 0 : _connector$on2.call(connector, 'disconnect', onDisconnect);\n    (_connector$on3 = connector.on) === null || _connector$on3 === void 0 ? void 0 : _connector$on3.call(connector, 'error', onError);\n  });\n  const {\n    provider,\n    webSocketProvider\n  } = this.config;\n  const subscribeProvider = typeof provider === 'function';\n  const subscribeWebSocketProvider = typeof webSocketProvider === 'function';\n  if (subscribeProvider || subscribeWebSocketProvider) this.store.subscribe(_ref2 => {\n    var _data$chain2;\n\n    let {\n      data\n    } = _ref2;\n    return data === null || data === void 0 ? void 0 : (_data$chain2 = data.chain) === null || _data$chain2 === void 0 ? void 0 : _data$chain2.id;\n  }, chainId => {\n    this.setState(x => ({ ...x,\n      provider: subscribeProvider ? provider({\n        chainId\n      }) : x.provider,\n      webSocketProvider: subscribeWebSocketProvider ? webSocketProvider({\n        chainId\n      }) : x.webSocketProvider\n    }));\n  });\n}\n\nlet client;\n\nfunction createClient(config) {\n  const client_ = new Client(config);\n  client = client_;\n  return client_;\n}\n\nfunction getClient() {\n  if (!client) {\n    warn('No client defined. Falling back to default client.');\n    return new Client();\n  }\n\n  return client;\n}\n\nexport { Client as C, InjectedConnector as I, createClient as a, createStorage as b, client as c, getClient as g, noopStorage as n };","map":{"version":3,"names":["b","Connector","_","_classPrivateMethodInitSpec","f","_defineProperty","g","_classPrivateFieldInitSpec","n","normalizeChainId","h","_classPrivateFieldGet","i","_classPrivateFieldSet","a","ConnectorNotFoundError","j","_classPrivateMethodGet","U","UserRejectedRequestError","R","ResourceUnavailableError","c","ChainNotConfiguredError","A","AddChainError","e","SwitchChainError","providers","getDefaultProvider","create","subscribeWithSelector","persist","getAddress","hexValue","allChains","getInjectedName","ethereum","_ethereum$providers","_getName","getName","provider","isBraveWallet","isCoinbaseWallet","isFrame","isOpera","isTally","isTokenary","isTrust","isMetaMask","length","_names$","nameSet","Set","unknownCount","name","concat","add","names","cache","warn","message","id","has","console","shimKey","_provider","WeakMap","_switchingChains","_isUserRejectedRequestError","WeakSet","InjectedConnector","constructor","chains","options","shimDisconnect","arguments","undefined","window","writable","value","accounts","emit","account","chainId","unsupported","isChainUnsupported","chain","_this$options","_this$options2","_getClient$storage","shimChainChangedDisconnect","getClient","storage","removeItem","overrideName","detectedName","connect","_this$options3","_getClient$storage2","getProvider","on","onAccountsChanged","onChainChanged","onDisconnect","type","getAccount","getChainId","switchChain","setItem","error","_isUserRejectedRequestError2","call","code","disconnect","_this$options4","_getClient$storage3","removeListener","request","method","then","getSigner","Promise","all","Web3Provider","isAuthorized","_this$options5","_getClient$storage4","getItem","_this$options6","_chains$find","params","find","x","network","rpcUrls","default","chainName","nativeCurrency","blockExplorerUrls","getBlockExplorerUrls","addError","watchAsset","_ref","address","decimals","image","symbol","noopStorage","_key","_value","createStorage","key","prefix","defaultState","JSON","parse","stringify","err","storeKey","_isAutoConnecting","_lastUsedConnector","_addEffects","Client","autoConnect","connectors","config","localStorage","webSocketProvider","_webSocketProvider","status","_chainId","_JSON$parse","_JSON$parse$state","_data$chain","rawState","data","state","_error","connectors_","provider_","webSocketProvider_","store","getStorage","partialize","_state$data","_state$data2","version","_addEffects2","getState","connector","lastUsedChainId","_this$data","_this$data$chain","subscribe","setState","updater","newState","clearState","destroy","_this$connector$disco","_this$connector","sorted","sort","connected","ready","setLastUsedConnector","_this$storage","lastUsedConnector","onChange","onError","prevConnector","_prevConnector$off","_prevConnector$off2","_prevConnector$off3","_connector$on","_connector$on2","_connector$on3","off","subscribeProvider","subscribeWebSocketProvider","_ref2","_data$chain2","client","createClient","client_","C","I"],"sources":["/home/king-longs/Desktop/final/node_modules/@wagmi/core/dist/client-e01209d5.esm.js"],"sourcesContent":["import { b as Connector, _ as _classPrivateMethodInitSpec, f as _defineProperty, g as _classPrivateFieldInitSpec, n as normalizeChainId, h as _classPrivateFieldGet, i as _classPrivateFieldSet, a as ConnectorNotFoundError, j as _classPrivateMethodGet, U as UserRejectedRequestError, R as ResourceUnavailableError, c as ChainNotConfiguredError, A as AddChainError, e as SwitchChainError } from './base-4c248b82.esm.js';\nimport { providers, getDefaultProvider } from 'ethers';\nimport create from 'zustand/vanilla';\nimport { subscribeWithSelector, persist } from 'zustand/middleware';\nimport { getAddress, hexValue } from 'ethers/lib/utils';\nimport { a as allChains } from './chains-42648bc5.esm.js';\n\nfunction getInjectedName(ethereum) {\n  var _ethereum$providers, _getName;\n\n  if (!ethereum) return 'Injected';\n\n  const getName = provider => {\n    if (provider.isBraveWallet) return 'Brave Wallet';\n    if (provider.isCoinbaseWallet) return 'Coinbase Wallet';\n    if (provider.isFrame) return 'Frame';\n    if (provider.isOpera) return 'Opera';\n    if (provider.isTally) return 'Tally';\n    if (provider.isTokenary) return 'Tokenary';\n    if (provider.isTrust) return 'Trust Wallet';\n    if (provider.isMetaMask) return 'MetaMask';\n  }; // Some injected providers detect multiple other providers and create a list at `ethers.providers`\n\n\n  if ((_ethereum$providers = ethereum.providers) !== null && _ethereum$providers !== void 0 && _ethereum$providers.length) {\n    var _names$;\n\n    // Deduplicate names using Set\n    // Coinbase Wallet puts multiple providers in `ethereum.providers`\n    const nameSet = new Set();\n    let unknownCount = 1;\n\n    for (const provider of ethereum.providers) {\n      let name = getName(provider);\n\n      if (!name) {\n        name = \"Unknown Wallet #\".concat(unknownCount);\n        unknownCount += 1;\n      }\n\n      nameSet.add(name);\n    }\n\n    const names = [...nameSet];\n    if (names.length) return names;\n    return (_names$ = names[0]) !== null && _names$ !== void 0 ? _names$ : 'Injected';\n  }\n\n  return (_getName = getName(ethereum)) !== null && _getName !== void 0 ? _getName : 'Injected';\n}\n\nconst cache = new Set();\nfunction warn(message, id) {\n  if (!cache.has(id !== null && id !== void 0 ? id : message)) {\n    console.warn(message);\n    cache.add(message);\n  }\n}\n\nconst shimKey = 'injected.shimDisconnect';\n\nvar _provider = /*#__PURE__*/new WeakMap();\n\nvar _switchingChains = /*#__PURE__*/new WeakMap();\n\nvar _isUserRejectedRequestError = /*#__PURE__*/new WeakSet();\n\nclass InjectedConnector extends Connector {\n  constructor() {\n    let {\n      chains,\n      options = {\n        shimDisconnect: true\n      }\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      chains,\n      options\n    });\n\n    _classPrivateMethodInitSpec(this, _isUserRejectedRequestError);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"ready\", typeof window != 'undefined' && !!window.ethereum);\n\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _switchingChains, {\n      writable: true,\n      value: void 0\n    });\n\n    _defineProperty(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) this.emit('disconnect');else this.emit('change', {\n        account: getAddress(accounts[0])\n      });\n    });\n\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit('change', {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n\n    _defineProperty(this, \"onDisconnect\", () => {\n      var _this$options, _this$options2, _getClient$storage;\n\n      // We need this as MetaMask can emit the \"disconnect\" event\n      // upon switching chains. This workaround ensures that the\n      // user currently isn't in the process of switching chains.\n      if ((_this$options = this.options) !== null && _this$options !== void 0 && _this$options.shimChainChangedDisconnect && _classPrivateFieldGet(this, _switchingChains)) {\n        _classPrivateFieldSet(this, _switchingChains, false);\n\n        return;\n      }\n\n      this.emit('disconnect');\n      if ((_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.shimDisconnect) (_getClient$storage = getClient().storage) === null || _getClient$storage === void 0 ? void 0 : _getClient$storage.removeItem(shimKey);\n    });\n\n    let name = 'Injected';\n\n    if (typeof window !== 'undefined') {\n      const overrideName = options.name;\n      const detectedName = getInjectedName(window.ethereum);\n      if (overrideName) name = typeof overrideName === 'function' ? overrideName(detectedName) : overrideName;else name = typeof detectedName === 'string' ? detectedName : detectedName[0];\n    }\n\n    this.id = 'injected';\n    this.name = name;\n  }\n\n  async connect() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      var _this$options3, _getClient$storage2;\n\n      const provider = await this.getProvider();\n      if (!provider) throw new ConnectorNotFoundError();\n\n      if (provider.on) {\n        provider.on('accountsChanged', this.onAccountsChanged);\n        provider.on('chainChanged', this.onChainChanged);\n        provider.on('disconnect', this.onDisconnect);\n      }\n\n      this.emit('message', {\n        type: 'connecting'\n      });\n      const account = await this.getAccount(); // Switch to chain if provided\n\n      let id = await this.getChainId();\n      let unsupported = this.isChainUnsupported(id);\n\n      if (chainId && id !== chainId) {\n        const chain = await this.switchChain(chainId);\n        id = chain.id;\n        unsupported = this.isChainUnsupported(id);\n      }\n\n      if ((_this$options3 = this.options) !== null && _this$options3 !== void 0 && _this$options3.shimDisconnect) (_getClient$storage2 = getClient().storage) === null || _getClient$storage2 === void 0 ? void 0 : _getClient$storage2.setItem(shimKey, true);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider\n      };\n    } catch (error) {\n      if (_classPrivateMethodGet(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, error)) throw new UserRejectedRequestError(error);\n      if (error.code === -32002) throw new ResourceUnavailableError(error);\n      throw error;\n    }\n  }\n\n  async disconnect() {\n    var _this$options4, _getClient$storage3;\n\n    const provider = await this.getProvider();\n    if (!(provider !== null && provider !== void 0 && provider.removeListener)) return;\n    provider.removeListener('accountsChanged', this.onAccountsChanged);\n    provider.removeListener('chainChanged', this.onChainChanged);\n    provider.removeListener('disconnect', this.onDisconnect);\n    if ((_this$options4 = this.options) !== null && _this$options4 !== void 0 && _this$options4.shimDisconnect) (_getClient$storage3 = getClient().storage) === null || _getClient$storage3 === void 0 ? void 0 : _getClient$storage3.removeItem(shimKey);\n  }\n\n  async getAccount() {\n    const provider = await this.getProvider();\n    if (!provider) throw new ConnectorNotFoundError();\n    const accounts = await provider.request({\n      method: 'eth_requestAccounts'\n    }); // return checksum address\n\n    return getAddress(accounts[0]);\n  }\n\n  async getChainId() {\n    const provider = await this.getProvider();\n    if (!provider) throw new ConnectorNotFoundError();\n    return await provider.request({\n      method: 'eth_chainId'\n    }).then(normalizeChainId);\n  }\n\n  async getProvider() {\n    if (typeof window !== 'undefined' && !!window.ethereum) _classPrivateFieldSet(this, _provider, window.ethereum);\n    return _classPrivateFieldGet(this, _provider);\n  }\n\n  async getSigner() {\n    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);\n    return new providers.Web3Provider(provider).getSigner(account);\n  }\n\n  async isAuthorized() {\n    try {\n      var _this$options5, _getClient$storage4;\n\n      if ((_this$options5 = this.options) !== null && _this$options5 !== void 0 && _this$options5.shimDisconnect && !((_getClient$storage4 = getClient().storage) !== null && _getClient$storage4 !== void 0 && _getClient$storage4.getItem(shimKey))) return false;\n      const provider = await this.getProvider();\n      if (!provider) throw new ConnectorNotFoundError();\n      const accounts = await provider.request({\n        method: 'eth_accounts'\n      });\n      const account = accounts[0];\n      return !!account;\n    } catch {\n      return false;\n    }\n  }\n\n  async switchChain(chainId) {\n    var _this$options6;\n\n    if ((_this$options6 = this.options) !== null && _this$options6 !== void 0 && _this$options6.shimChainChangedDisconnect) _classPrivateFieldSet(this, _switchingChains, true);\n    const provider = await this.getProvider();\n    if (!provider) throw new ConnectorNotFoundError();\n    const id = hexValue(chainId);\n\n    try {\n      var _chains$find;\n\n      await provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{\n          chainId: id\n        }]\n      });\n      const chains = [...this.chains, ...allChains];\n      return (_chains$find = chains.find(x => x.id === chainId)) !== null && _chains$find !== void 0 ? _chains$find : {\n        id: chainId,\n        name: \"Chain \".concat(id),\n        network: \"\".concat(id),\n        rpcUrls: {\n          default: ''\n        }\n      };\n    } catch (error) {\n      const chain = this.chains.find(x => x.id === chainId);\n      if (!chain) throw new ChainNotConfiguredError(); // Indicates chain is not added to provider\n\n      if (error.code === 4902) {\n        try {\n          await provider.request({\n            method: 'wallet_addEthereumChain',\n            params: [{\n              chainId: id,\n              chainName: chain.name,\n              nativeCurrency: chain.nativeCurrency,\n              rpcUrls: [chain.rpcUrls.default],\n              blockExplorerUrls: this.getBlockExplorerUrls(chain)\n            }]\n          });\n          return chain;\n        } catch (addError) {\n          if (_classPrivateMethodGet(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, addError)) throw new UserRejectedRequestError(error);\n          throw new AddChainError();\n        }\n      }\n\n      if (_classPrivateMethodGet(this, _isUserRejectedRequestError, _isUserRejectedRequestError2).call(this, error)) throw new UserRejectedRequestError(error);\n      throw new SwitchChainError(error);\n    }\n  }\n\n  async watchAsset(_ref) {\n    let {\n      address,\n      decimals = 18,\n      image,\n      symbol\n    } = _ref;\n    const provider = await this.getProvider();\n    if (!provider) throw new ConnectorNotFoundError();\n    return await provider.request({\n      method: 'wallet_watchAsset',\n      params: {\n        type: 'ERC20',\n        options: {\n          address,\n          decimals,\n          image,\n          symbol\n        }\n      }\n    });\n  }\n\n}\n\nfunction _isUserRejectedRequestError2(error) {\n  return error.code === 4001;\n}\n\nconst noopStorage = {\n  getItem: _key => '',\n  setItem: (_key, _value) => null,\n  removeItem: _key => null\n};\nfunction createStorage(_ref) {\n  let {\n    storage,\n    key: prefix = 'wagmi'\n  } = _ref;\n  return { ...storage,\n    getItem: function (key) {\n      let defaultState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      const value = storage.getItem(\"\".concat(prefix, \".\").concat(key));\n\n      try {\n        return value ? JSON.parse(value) : defaultState;\n      } catch (error) {\n        console.warn(error);\n        return defaultState;\n      }\n    },\n    setItem: (key, value) => {\n      if (value === null) {\n        storage.removeItem(\"\".concat(prefix, \".\").concat(key));\n      } else {\n        try {\n          storage.setItem(\"\".concat(prefix, \".\").concat(key), JSON.stringify(value));\n        } catch (err) {\n          console.error(err);\n        }\n      }\n    },\n    removeItem: key => storage.removeItem(\"\".concat(prefix, \".\").concat(key))\n  };\n}\n\nconst storeKey = 'store';\n\nvar _isAutoConnecting = /*#__PURE__*/new WeakMap();\n\nvar _lastUsedConnector = /*#__PURE__*/new WeakMap();\n\nvar _addEffects = /*#__PURE__*/new WeakSet();\n\nclass Client {\n  constructor() {\n    let {\n      autoConnect = false,\n      connectors = [new InjectedConnector()],\n      provider: _provider = config => {\n        try {\n          return getDefaultProvider(config.chainId);\n        } catch {\n          return getDefaultProvider();\n        }\n      },\n      storage = createStorage({\n        storage: typeof window !== 'undefined' ? window.localStorage : noopStorage\n      }),\n      webSocketProvider: _webSocketProvider\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classPrivateMethodInitSpec(this, _addEffects);\n\n    _defineProperty(this, \"config\", void 0);\n\n    _defineProperty(this, \"storage\", void 0);\n\n    _defineProperty(this, \"store\", void 0);\n\n    _classPrivateFieldInitSpec(this, _isAutoConnecting, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _lastUsedConnector, {\n      writable: true,\n      value: void 0\n    });\n\n    // Check status for autoConnect flag\n    let status = 'disconnected';\n\n    let _chainId;\n\n    if (autoConnect) {\n      try {\n        var _JSON$parse, _JSON$parse$state, _data$chain;\n\n        const rawState = storage.getItem(storeKey, '');\n        const data = (_JSON$parse = JSON.parse(rawState || '{}')) === null || _JSON$parse === void 0 ? void 0 : (_JSON$parse$state = _JSON$parse.state) === null || _JSON$parse$state === void 0 ? void 0 : _JSON$parse$state.data; // If account exists in localStorage, set status to reconnecting\n\n        status = data !== null && data !== void 0 && data.account ? 'reconnecting' : 'connecting';\n        _chainId = data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id; // eslint-disable-next-line no-empty\n      } catch (_error) {}\n    } // Evaluate initial store values\n\n\n    const connectors_ = typeof connectors === 'function' ? connectors({\n      chainId: _chainId\n    }) : connectors;\n    const provider_ = typeof _provider === 'function' ? _provider({\n      chainId: _chainId\n    }) : _provider;\n    const webSocketProvider_ = typeof _webSocketProvider === 'function' ? _webSocketProvider({\n      chainId: _chainId\n    }) : _webSocketProvider; // Create store\n\n    this.store = create(subscribeWithSelector(persist(() => ({\n      connectors: connectors_,\n      provider: provider_,\n      status,\n      webSocketProvider: webSocketProvider_\n    }), {\n      name: storeKey,\n      getStorage: () => storage,\n      partialize: state => {\n        var _state$data, _state$data2;\n\n        return { ...(autoConnect && {\n            data: {\n              account: state === null || state === void 0 ? void 0 : (_state$data = state.data) === null || _state$data === void 0 ? void 0 : _state$data.account,\n              chain: state === null || state === void 0 ? void 0 : (_state$data2 = state.data) === null || _state$data2 === void 0 ? void 0 : _state$data2.chain\n            }\n          }),\n          chains: state === null || state === void 0 ? void 0 : state.chains\n        };\n      },\n      version: 1\n    })));\n    this.config = {\n      autoConnect,\n      connectors,\n      provider: _provider,\n      storage,\n      webSocketProvider: _webSocketProvider\n    };\n    this.storage = storage;\n\n    _classPrivateFieldSet(this, _lastUsedConnector, storage === null || storage === void 0 ? void 0 : storage.getItem('wallet'));\n\n    _classPrivateMethodGet(this, _addEffects, _addEffects2).call(this);\n  }\n\n  get chains() {\n    return this.store.getState().chains;\n  }\n\n  get connectors() {\n    return this.store.getState().connectors;\n  }\n\n  get connector() {\n    return this.store.getState().connector;\n  }\n\n  get data() {\n    return this.store.getState().data;\n  }\n\n  get error() {\n    return this.store.getState().error;\n  }\n\n  get lastUsedChainId() {\n    var _this$data, _this$data$chain;\n\n    return (_this$data = this.data) === null || _this$data === void 0 ? void 0 : (_this$data$chain = _this$data.chain) === null || _this$data$chain === void 0 ? void 0 : _this$data$chain.id;\n  }\n\n  get provider() {\n    return this.store.getState().provider;\n  }\n\n  get status() {\n    return this.store.getState().status;\n  }\n\n  get subscribe() {\n    return this.store.subscribe;\n  }\n\n  get webSocketProvider() {\n    return this.store.getState().webSocketProvider;\n  }\n\n  setState(updater) {\n    const newState = typeof updater === 'function' ? updater(this.store.getState()) : updater;\n    this.store.setState(newState, true);\n  }\n\n  clearState() {\n    this.setState(x => ({ ...x,\n      chains: undefined,\n      connector: undefined,\n      data: undefined,\n      error: undefined,\n      status: 'disconnected'\n    }));\n  }\n\n  async destroy() {\n    var _this$connector$disco, _this$connector;\n\n    if (this.connector) await ((_this$connector$disco = (_this$connector = this.connector).disconnect) === null || _this$connector$disco === void 0 ? void 0 : _this$connector$disco.call(_this$connector));\n\n    _classPrivateFieldSet(this, _isAutoConnecting, false);\n\n    this.clearState();\n    this.store.destroy();\n  }\n\n  async autoConnect() {\n    if (_classPrivateFieldGet(this, _isAutoConnecting)) return;\n\n    _classPrivateFieldSet(this, _isAutoConnecting, true);\n\n    if (!this.connectors.length) return; // Try last used connector first\n\n    const sorted = _classPrivateFieldGet(this, _lastUsedConnector) ? [...this.connectors].sort(x => x.id === _classPrivateFieldGet(this, _lastUsedConnector) ? -1 : 1) : this.connectors;\n    let connected = false;\n\n    for (const connector of sorted) {\n      if (!connector.ready || !connector.isAuthorized) continue;\n      const isAuthorized = await connector.isAuthorized();\n      if (!isAuthorized) continue;\n      const data = await connector.connect();\n      this.setState(x => ({ ...x,\n        connector,\n        chains: connector === null || connector === void 0 ? void 0 : connector.chains,\n        data,\n        status: 'connected'\n      }));\n      connected = true;\n      break;\n    } // If connecting didn't succeed, set to disconnected\n\n\n    if (!connected) this.setState(x => ({ ...x,\n      data: undefined,\n      status: 'disconnected'\n    }));\n\n    _classPrivateFieldSet(this, _isAutoConnecting, false);\n\n    return this.data;\n  }\n\n  setLastUsedConnector() {\n    var _this$storage;\n\n    let lastUsedConnector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    (_this$storage = this.storage) === null || _this$storage === void 0 ? void 0 : _this$storage.setItem('wallet', lastUsedConnector);\n  }\n\n}\n\nfunction _addEffects2() {\n  const onChange = data => {\n    this.setState(x => ({ ...x,\n      data: { ...x.data,\n        ...data\n      }\n    }));\n  };\n\n  const onDisconnect = () => {\n    this.clearState();\n  };\n\n  const onError = error => {\n    this.setState(x => ({ ...x,\n      error\n    }));\n  };\n\n  this.store.subscribe(_ref => {\n    let {\n      connector\n    } = _ref;\n    return connector;\n  }, (connector, prevConnector) => {\n    var _prevConnector$off, _prevConnector$off2, _prevConnector$off3, _connector$on, _connector$on2, _connector$on3;\n\n    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off = prevConnector.off) === null || _prevConnector$off === void 0 ? void 0 : _prevConnector$off.call(prevConnector, 'change', onChange);\n    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off2 = prevConnector.off) === null || _prevConnector$off2 === void 0 ? void 0 : _prevConnector$off2.call(prevConnector, 'disconnect', onDisconnect);\n    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off3 = prevConnector.off) === null || _prevConnector$off3 === void 0 ? void 0 : _prevConnector$off3.call(prevConnector, 'error', onError);\n    if (!connector) return;\n    (_connector$on = connector.on) === null || _connector$on === void 0 ? void 0 : _connector$on.call(connector, 'change', onChange);\n    (_connector$on2 = connector.on) === null || _connector$on2 === void 0 ? void 0 : _connector$on2.call(connector, 'disconnect', onDisconnect);\n    (_connector$on3 = connector.on) === null || _connector$on3 === void 0 ? void 0 : _connector$on3.call(connector, 'error', onError);\n  });\n  const {\n    provider,\n    webSocketProvider\n  } = this.config;\n  const subscribeProvider = typeof provider === 'function';\n  const subscribeWebSocketProvider = typeof webSocketProvider === 'function';\n  if (subscribeProvider || subscribeWebSocketProvider) this.store.subscribe(_ref2 => {\n    var _data$chain2;\n\n    let {\n      data\n    } = _ref2;\n    return data === null || data === void 0 ? void 0 : (_data$chain2 = data.chain) === null || _data$chain2 === void 0 ? void 0 : _data$chain2.id;\n  }, chainId => {\n    this.setState(x => ({ ...x,\n      provider: subscribeProvider ? provider({\n        chainId\n      }) : x.provider,\n      webSocketProvider: subscribeWebSocketProvider ? webSocketProvider({\n        chainId\n      }) : x.webSocketProvider\n    }));\n  });\n}\n\nlet client;\nfunction createClient(config) {\n  const client_ = new Client(config);\n  client = client_;\n  return client_;\n}\nfunction getClient() {\n  if (!client) {\n    warn('No client defined. Falling back to default client.');\n    return new Client();\n  }\n\n  return client;\n}\n\nexport { Client as C, InjectedConnector as I, createClient as a, createStorage as b, client as c, getClient as g, noopStorage as n };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}